<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>入院初体验</title>
      <link href="posts/990f9e05.html"/>
      <url>posts/990f9e05.html</url>
      
        <content type="html"><![CDATA[<ul><li><strong>糟糕的一个月</strong></li></ul><p>上个月右脚膝盖肿痛🤧，不幸痛风复发，哐当入院,经历了人生第一次手术和应该算第一次真正的住院了。</p><p>痛风真的很痛苦，大家还是引以为戒吧!!! </p><p>少熬夜，多吃素 🤧</p><p>不过三甲医院的住院还是和二甲有区别的，第一个就是环境好，没有二甲医院那么嘈杂，护士小姐姐也人美声甜 😍</p><p>由于是规定了探视时间，所以也没有很多人吵闹，住下来，除了病痛外体验都很好。</p><p><img src="/medias/loading.gif" data-original="/posts/990f9e05/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202304191602563.jpg"></p><ul><li><p><strong>手术初体验</strong></p><p>手术没有想象中的恐怖，手术当天不喝水，不吃东西，直到下午4点进手术室。</p><p>手术室的空调巨冷,带上各种监测心率血压的仪器后，往背部打了好几针，隔了一会后下半身就麻痹了，后来带上呼吸面罩，应该吸的是麻药吧，后来中途醒了1，2次，迷迷糊糊听到医生在边做手术，边讨论日常琐事，后来醒过来就在监护室了。(电视剧都是骗人的，医生并没有想象中的那么严肃，手术也没有多恐怖）</p><p>后面送回了病房后，吸氧，打吊针，监测一套下来就到了第二天了🤧，总的来说就相当于我睡了一觉后手术就完成了，现代医学还是很了不起的😉</p><p><img src="/medias/loading.gif" data-original="/posts/990f9e05/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202304191602564.jpg"></p></li><li><p><strong>一些关于医院的其他</strong></p><p>算是第一次住院和动手术了，为什么要说算是，因为之前短暂的在二甲医院呆了一次，但是上午做理疗，下午晚上不在的那种。这次全天都在，应该算是正式住过院了。</p><p>医院的饭菜还行，扫二维码自主订餐，不确定是每栋楼都会有不同的餐饮还是说怎么样，但如果从我角度出发的话，能吃的其实并不多，大荤会比较多，其他也ok。（并没有在说坏话的意思</p><p><img src="/medias/loading.gif" data-original="/posts/990f9e05/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230419160256.jpg"></p></li><li><p>当我去拍片准备做手术后，我才发现医院的人是真滴多，像平常我去医院看门诊，一般医院会有步梯和扶梯和电梯供上下，一般在低一点楼层的话，我都是选择扶梯和步梯，因为电梯实际上是为了更高楼层或者行动不变的患者使用的。</p><p>因为我当时比较严重，需要坐轮椅上下，医院电梯大概有3，4部，当我看到大家都挤在电梯前时，我是有点不理解的，毕竟当时只是在4楼，大家看起来也并不是行动不便，不理解为什么非要等那5分钟电梯，其实5分钟也足够从4楼走回去了吧，一大堆人乌泱泱往里冲时，后面还躺着一个像是刚生完孩子的妈妈躺在病床上。感觉也不是特别好看。</p></li><li><p>护工阿姨其实特别幸苦，有一天阿姨和我说要值24小时班时是真的有点吓到我了，说是因为另一个护工阿姨请假，因为是类似团队，一对多这样子的模式，相当于3班倒，一个阿姨请假后就相当于需要平摊剩下的时间，但其他的我也不是很清楚，只能说赚的都是辛苦钱吧😔</p></li><li><p>最后祝大家心明眼亮，身体健康，有些东西还是不要有初体验好。</p></li></ul><p><img src="/medias/loading.gif" data-original="/posts/990f9e05/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_202304191602561.jpg"></p><p>  PS：(医生是真的很喜欢穿洞洞鞋，不知道是不是有规定还是什么，进了手术室后好像大家都是穿的洞洞鞋，没有例外，偶尔查房的医生也是穿着洞洞鞋，包括我去做一些检查，医生也是穿着洞洞鞋🤔)</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx 命令</title>
      <link href="posts/f79446df.html"/>
      <url>posts/f79446df.html</url>
      
        <content type="html"><![CDATA[<p><code> 写在前面,一些nginx命令的汇总,后面有空的话写下nginx一些功能的nginx文件修改</code></p><h2 id="1-ngxin的安装"><a href="#1-ngxin的安装" class="headerlink" title="1. ngxin的安装"></a>1. ngxin的安装</h2><p><a href="http://nginx.org/en/download.html">http://nginx.org/en/download.html</a>  下载安装包地址</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">1</span>.先安装环境:<span class="token function">sudo</span> yum <span class="token function">install</span> gcc-c++<span class="token function">sudo</span> yum <span class="token function">install</span> <span class="token parameter variable">-y</span> pcre pcre-devel<span class="token function">sudo</span> yum <span class="token function">install</span> <span class="token parameter variable">-y</span> zlib zlib-devel<span class="token function">sudo</span> yum <span class="token function">install</span> <span class="token parameter variable">-y</span> openssl openssl-devel<span class="token number">2</span>.再解压安装包<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> nginx-1.12.0.tar.gz<span class="token builtin class-name">cd</span> nginx-1.12.0<span class="token number">3</span>.配置一些置nginx编译环境。 该命令定义了系统各方面功能，如果不配置默认为空即可./configure<span class="token number">4</span>.要配置一些命令基本是这样子的，./configure    --sbin-path<span class="token operator">=</span>/usr/local/nginx/nginx    --conf-path<span class="token operator">=</span>/usr/local/nginx/nginx.conf    --pid-path<span class="token operator">=</span>/usr/local/nginx/nginx.pid    --with-http_ssl_module    --with-pcre<span class="token operator">=</span><span class="token punctuation">..</span>/pcre-4.4    --with-zlib<span class="token operator">=</span><span class="token punctuation">..</span>/zlib-1.1.3    <span class="token number">5</span>.编译<span class="token function">make</span> <span class="token operator">&amp;&amp;</span>  <span class="token function">make</span> <span class="token function">install</span><span class="token number">6</span>. 启动nginx,正常到nginx目录下有nginx的二进制文件，手动启动即可<span class="token builtin class-name">cd</span> /usr/local/nginx/sbin/./nginx<span class="token number">7</span>.查看nginx程序，正常会有一个nginx的主进程正常运行<span class="token function">ps</span> <span class="token parameter variable">-aux</span> <span class="token operator">|</span> <span class="token function">grep</span> nginx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-nginx的命令行参数"><a href="#2-nginx的命令行参数" class="headerlink" title="2. nginx的命令行参数"></a>2. nginx的命令行参数</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./nginx-h/-? <span class="token comment"># 打开帮助</span><span class="token parameter variable">-c</span> <span class="token comment"># 使用指定的配置文件，而不是默认的 conf 文件夹下的配置文件</span><span class="token parameter variable">-g</span> <span class="token comment"># 指定配置命令，覆盖掉配置文件中的指令</span><span class="token parameter variable">-p</span> <span class="token comment"># 指定运行目录</span><span class="token parameter variable">-s</span> <span class="token comment"># 发送信号 stop 立刻停止服务；quit 优雅的停止服务；reload 重载配置文件；reopen 重新开始记录日志文件</span>-t/-T <span class="token comment"># 测试配置文件是否有语法错误</span>-v/-V <span class="token comment"># 打印 nginx 的版本信息、编译信息等</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-nginx-信号"><a href="#3-nginx-信号" class="headerlink" title="3. nginx 信号"></a>3. nginx 信号</h2><table><thead><tr><th>信号</th><th>作用</th></tr></thead><tbody><tr><td>TERM或INT</td><td>快速停止Nginx服务</td></tr><tr><td>QUIT</td><td>平缓停止Nginx服务</td></tr><tr><td>HUP</td><td>使用新的配置文件启动进程，之后平缓停止原有进程，“平滑重启”的功能</td></tr><tr><td>USR1</td><td>重新打开日志文件，常用于日志切割</td></tr><tr><td>USR2</td><td>使用新版本的Nginx文件启动服务，之后平缓停止原有进程，“平滑升级”的功能</td></tr><tr><td>WINCH</td><td>平缓停止worker进程，用于Nginx服务器平滑升级</td></tr></tbody></table><h2 id="4-nginx-启动、停止、重启命令"><a href="#4-nginx-启动、停止、重启命令" class="headerlink" title="4. nginx 启动、停止、重启命令"></a>4. nginx 启动、停止、重启命令</h2><ul><li><strong>nginx启动</strong></li></ul> <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/local/nginx/nginx     <span class="token punctuation">(</span>nginx二进制文件绝对路径，可以根据自己安装路径实际决定<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><strong>nginx指定配置文件启动</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">/usr/local/nginx/sbin/nginx <span class="token parameter variable">-c</span> conf/nginx.conf        <span class="token punctuation">(</span>nginx配置文件绝对路径，可以根据自己路径实际决定，一个主进程只能有一个配置文件<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>nginx从容停止命令，等所有请求结束后关闭服务</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span><span class="token function">grep</span> nginx<span class="token function">kill</span> <span class="token parameter variable">-QUIT</span>  nginx主进程号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>nginx 快速停止命令，立刻关闭nginx进程</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span><span class="token function">grep</span> nginx<span class="token function">kill</span> <span class="token parameter variable">-TERM</span> nginx主进程号 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>如果以上命令不管用，可以强制停止</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span><span class="token function">grep</span> nginx<span class="token function">kill</span> <span class="token parameter variable">-9</span> nginx主进程号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>nginx重启命令</strong></p></li></ul><p>nginx重启可以分成几种类型</p><p>1.简单型，先关闭进程，修改你的配置后，启动进程。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> <span class="token parameter variable">-QUIT</span>  nginx主进程号/usr/local/nginx/nginx <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>2.重新加载配置文件，不重启进程，不会停止处理请求</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> <span class="token parameter variable">-HUP</span>  nginx主进程号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5.其他"></a>5.其他</h2><p>Nginx在配置变量 $host $http_host和$proxy_host 区别“</p><table><thead><tr><th><strong>变量</strong></th><th><strong>是否显示端口</strong></th><th><strong>值</strong></th></tr></thead><tbody><tr><td>$host</td><td>不显示端口</td><td>浏览器请求的ip</td></tr><tr><td>$http_host</td><td>端口存在则显示</td><td>浏览器请求的ip和端口号</td></tr><tr><td>$proxy_host</td><td>默认80端口不显示，其它显示</td><td>被代理服务的ip和端口号</td></tr></tbody></table><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些常用的配置文档说明</title>
      <link href="posts/705c1a66.html"/>
      <url>posts/705c1a66.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>一些常用的配置文档说明 </p></blockquote><h2 id="1-nginx命令配置"><a href="#1-nginx命令配置" class="headerlink" title="1. nginx命令配置"></a>1. nginx命令配置</h2><p>ngxin的模块实在是太多了，慢慢来吧，挑一些重要的讲 ;-)</p><ol><li><strong>核心配置</strong></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> <span class="token comment">########   Nginx的main(全局配置)文件</span> <span class="token comment">#指定nginx运行的用户及用户组,默认为nobody</span>user  nobody<span class="token punctuation">;</span>     <span class="token comment">#开启的线程数，一般跟逻辑CPU核数一致</span> worker_processes  <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">#定位全局错误日志文件，级别以notice显示，还有debug,info,warn,error,crit模式，debug输出最多，crir输出最少，根据实际环境而定</span> <span class="token comment">#error_log  logs/error.log;</span><span class="token number">4</span> <span class="token comment">#error_log  logs/error.log  notice;</span> <span class="token comment">#error_log  logs/error.log  info;</span>  <span class="token comment">#指定进程id的存储文件位置</span> <span class="token comment">#pid        logs/nginx.pid;</span>  <span class="token comment">#指定一个nginx进程打开的最多文件描述符数目，受系统进程的最大打开文件数量限制</span> <span class="token comment">#worker_rlimit_nofile 65535</span>  events <span class="token punctuation">{</span>     <span class="token comment">#设置工作模式为epoll,除此之外还有select,poll,kqueue,rtsig和/dev/poll模式    #use epoll;</span>     <span class="token comment">#定义每个进程的最大连接数,受系统进程的最大打开文件数量限制。</span>     worker_connections  <span class="token number">1024</span><span class="token comment">#同时接受多个新网络连接请求的功multi_accept on</span> <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p><strong>Http服务器配置</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#######Nginx的Http服务器配置,Gzip配置</span>http <span class="token punctuation">{</span>    <span class="token comment">#主模块指令，实现对配置文件所包含的文件的设定，可以减少主配置文件的复杂度，DNS主配置文件中的zonerfc1912,acl基本上都是用include语句。</span>    include       mime.types<span class="token punctuation">;</span>        <span class="token comment">#核心模块指令，智力默认设置为二进制流，也就是当文件类型未定义时使用这种方式</span>    default_type  application/octet-stream<span class="token punctuation">;</span>    <span class="token comment">#下面代码为日志格式的设定，main为日志格式的名称，可自行设置，后面引用</span>    <span class="token comment">#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '</span>    <span class="token comment">#                  '$status $body_bytes_sent "$http_referer" '</span>    <span class="token comment">#                  '"$http_user_agent" "$http_x_forwarded_for"';</span>    <span class="token comment">#引用日志main</span>    <span class="token comment">#access_log  logs/access.log  main;</span>    <span class="token comment">#设置允许客户端请求的最大的单个文件字节数</span>    <span class="token comment">#client_max_body_size 20M;</span>    <span class="token comment">#指定来自客户端请求头的headebuffer大小</span>    <span class="token comment">#client_header_buffer_size  32k;</span>    <span class="token comment">#指定连接请求试图写入缓存文件的目录路径</span>    <span class="token comment">#client_body_temp_path /dev/shm/client_body_temp;</span>    <span class="token comment">#指定客户端请求中较大的消息头的缓存最大数量和大小，目前设置为4个32KB</span>    <span class="token comment">#large client_header_buffers 4 32k;</span>        <span class="token comment">#开启高效文件传输模式</span>    sendfile        on<span class="token punctuation">;</span>    <span class="token comment">#开启防止网络阻塞 /静态文件是 不要标志PUSH,而是等tcp缓冲满了，再发送</span>    <span class="token comment">#tcp_nopush     on;</span>    <span class="token comment">#开启防止网络阻塞/动态文件，立马发送。</span>    <span class="token comment">#tcp_nodelay    on;</span>     <span class="token comment">#设置客户端连接保存活动的超时时间  #keepalive_timeout  0; keepalive_timeout  65;</span><span class="token comment">#指定nginx与后端FastCGI server连接超时时fastcgi_connect_timeout 60#指定nginx向后端传送请求超时时fastcgi_send_timeout 60#指定nginx接受后端fastcgi响应请求超时时fastcgi_read_timeout 60#指定nginx读取fastcgi响应第一部分需要用多大的缓冲fastcgi_buffer_size 4k|8指nginx需要用多大的缓冲区缓冲fastcgi的应答请fastcgi_buffers num size8 4k|#整个数据请求需要多大的缓存fastcgi_busy_buffers 8k|16</span>     <span class="token comment">#设置客户端请求读取超时时间</span>    <span class="token comment">#client_header_timeout 10;</span>    <span class="token comment">#设置客户端请求主体读取超时时间</span>    <span class="token comment">#client_body_timeout 10;</span>    <span class="token comment">#用于设置相应客户端的超时时间</span>    <span class="token comment">#send_timeout </span>        <span class="token comment">####HttpGZip模块配置</span>    <span class="token comment">#httpGzip modules</span>    <span class="token comment">#开启gzip压缩</span>    <span class="token comment">#gzip  on;</span>    <span class="token comment">#设置允许压缩的页面最小字节数</span>    <span class="token comment">#gzip_min_length 1k;</span>    <span class="token comment">#申请4个单位为16K的内存作为压缩结果流缓存</span>    <span class="token comment">#gzip_buffers 4 16k;</span>    <span class="token comment">#设置识别http协议的版本，默认为1.1</span>    <span class="token comment">#gzip_http_version 1.1;</span>    <span class="token comment">#指定gzip压缩比，1-9数字越小，压缩比越小，速度越快</span>    <span class="token comment">#gzip_comp_level 2;</span>    <span class="token comment">#指定压缩的类型</span>    <span class="token comment">#gzip_types text/plain application/x-javascript text/css application/xml;</span>    <span class="token comment">#让前端的缓存服务器进过gzip压缩的页面</span>    <span class="token comment">#gzip_vary on; #基于代理服务器的类型来决定是否进行压缩</span>    <span class="token comment">#gzip_proxied   expired no-cache no-store private auth</span>        <span class="token comment">#设定虚拟主机配置</span>   server <span class="token punctuation">{</span>       <span class="token comment">#侦听80端口</span>       listen    <span class="token number">80</span><span class="token punctuation">;</span>       <span class="token comment">#定义使用 www.nginx.cn访问</span>       server_name  www.nginx.cn<span class="token punctuation">;</span>       <span class="token comment">#定义服务器的默认网站根目录位置</span>       root html<span class="token punctuation">;</span>       <span class="token comment">#设定本虚拟主机的访问日志</span>       access_log  logs/nginx.access.log  main<span class="token punctuation">;</span>       <span class="token comment">#默认请求</span>       location / <span class="token punctuation">{</span>           <span class="token comment">#定义首页索引文件的名称</span>           index index.php index.html index.htm<span class="token punctuation">;</span>             <span class="token punctuation">}</span>       <span class="token comment"># 定义错误提示页面</span>       error_page   <span class="token number">500</span> <span class="token number">502</span> <span class="token number">503</span> <span class="token number">504</span> /50x.html<span class="token punctuation">;</span>       location <span class="token operator">=</span> /50x.html <span class="token punctuation">{</span>       <span class="token punctuation">}</span>       <span class="token comment">#静态文件，nginx自己处理</span>       location ~ ^/<span class="token punctuation">(</span>images<span class="token operator">|</span>javascript<span class="token operator">|</span>js<span class="token operator">|</span>css<span class="token operator">|</span>flash<span class="token operator">|</span>media<span class="token operator">|</span>static<span class="token punctuation">)</span>/ <span class="token punctuation">{</span>           <span class="token comment">#过期30天，静态文件不怎么更新，过期可以设大一点，</span>           <span class="token comment">#如果频繁更新，则可以设置得小一点。-1 为永远过期</span>           expires 30d<span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token comment">#禁止访问 .htxxx 文件</span>           location ~ /.ht <span class="token punctuation">{</span>           deny all<span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><p><strong>反向代理配置</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#nginx的反向代理配置</span><span class="token comment">#proxy_pass：指定需要反向代理的服务器地址，可以是一个upstream池</span><span class="token comment">#proxy_next_upstream：如果后端服务器不可用的话自动将请求转发到另一台服务器，默认为on，还可以设置为timeout或者http状态码</span><span class="token comment">#proxy_method：修改用户的method请求</span><span class="token comment">#proxy_http_version：修改用户的http协议版本</span><span class="token comment">#proxy_set_header：修改用户header头部，如客户端真实IP信息，也是配置较多的选项</span><span class="token comment">#proxy_set_body：修改用户包体信息</span><span class="token comment">#proxy_send_timeout：默认60S</span><span class="token comment">#proxy_connect_timeout：默认60S，Nginx与后端服务器连接超时时间</span><span class="token comment">#定义一个upstream池</span>upstream name <span class="token punctuation">{</span>  ip_hash<span class="token punctuation">;</span><span class="token comment"># 负载均衡指令 （hash,ip_hash,least_conn,stickty,哈希,根据iphash,最小请求原则，cookie分布)</span>  server   backend1.example.com<span class="token punctuation">;</span>  server   backend2.example.com<span class="token punctuation">;</span>  server   backend3.example.com    server   backend4.example.com<span class="token punctuation">;</span><span class="token punctuation">}</span>location /test <span class="token punctuation">{</span>        proxy_pass http://test<span class="token punctuation">;</span>        proxy_http_version <span class="token number">1.1</span><span class="token punctuation">;</span>proxy_set_header Upgrade <span class="token variable">$http_upgrade</span><span class="token punctuation">;</span>        proxy_set_header Connection <span class="token variable">$connection_upgrade</span><span class="token punctuation">;</span>        proxy_read_timeout 30s<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><p><strong>SSL证书配置</strong></p><p>证书的话要安装模块</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">./nginx <span class="token parameter variable">-V</span>  如果出现 <span class="token punctuation">(</span>configure arguments: --with-http_ssl_module<span class="token punctuation">)</span>, 则已安装进入nginx目录,安装模块./configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module编译<span class="token function">make</span> 上述操作执行完成以后，你的目录下会出现objs文件夹,进入目录，找到二进制nginx文件替换当前二进制文件即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server <span class="token punctuation">{</span>    listen <span class="token number">80</span><span class="token punctuation">;</span>    server_name www.nginx.cn<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">#nginx的证书配置</span><span class="token comment">#listen：开启ssl模块,监听443端口，https端口443</span><span class="token comment">#server_name：绑定证书的域名</span><span class="token comment">#ssl_certificate：证书文件的相对路径或绝对路径</span><span class="token comment">#ssl_certificate_key：私钥文件的相对路径或绝对路径</span><span class="token comment">#ssl_session_timeout ：超时时间</span><span class="token comment">#ssl_protocols：启用指定的加密协议</span><span class="token comment">#ssl_ciphers ：加密算法</span><span class="token comment">#ssl_prefer_server_ciphers：使用服务器端的首选算法</span>server<span class="token punctuation">{</span>    listen <span class="token number">443</span> ssl<span class="token punctuation">;</span>    server_name www.nginx.cn<span class="token punctuation">;</span>    ssl_certificate /etc/nginx/ssl.conf/lebang2020.cn.pem<span class="token punctuation">;</span>    ssl_certificate_key /etc/nginx/ssl.conf/lebang2020.cn.key<span class="token punctuation">;</span>    ssl_session_timeout 5m<span class="token punctuation">;</span>    ssl_protocols TLSv1 TLSv1.1 TLSv1.2<span class="token punctuation">;</span>    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:<span class="token operator">!</span>aNULL:<span class="token operator">!</span>MD5:<span class="token operator">!</span>RC4:<span class="token operator">!</span>DHE<span class="token punctuation">;</span>    ssl_prefer_server_ciphers on<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li><p><strong>nginx中设置Ip黑名单</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/nginx/conf.d/ip.confdeny <span class="token number">127.0</span>.0.1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol></li></ol></li></ol><h2 id="2-redis-配置文件"><a href="#2-redis-配置文件" class="headerlink" title="2. redis 配置文件"></a>2. redis 配置文件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># Redis 配置文件示例</span><span class="token comment"># 注意单位: 当需要配置内存大小时, 可能需要指定像1k,5GB,4M等常见格式</span><span class="token comment">#</span><span class="token comment"># 1k =&gt; 1000 bytes</span><span class="token comment"># 1kb =&gt; 1024 bytes</span><span class="token comment"># 1m =&gt; 1000000 bytes</span><span class="token comment"># 1mb =&gt; 1024*1024 bytes</span><span class="token comment"># 1g =&gt; 1000000000 bytes</span><span class="token comment"># 1gb =&gt; 1024*1024*1024 bytes</span><span class="token comment">#</span><span class="token comment"># 单位是对大小写不敏感的 1GB 1Gb 1gB 是相同的。</span><span class="token comment">################################## INCLUDES ###################################</span><span class="token comment"># 可以在这里包含一个或多个其他的配置文件。如果你有一个适用于所有Redis服务器的标准配置模板</span><span class="token comment"># 但也需要一些每个服务器自定义的设置，这个功能将很有用。被包含的配置文件也可以包含其他配置文件，</span><span class="token comment"># 所以需要谨慎的使用这个功能。</span><span class="token comment">#</span><span class="token comment"># 注意“inclue”选项不能被admin或Redis哨兵的"CONFIG REWRITE"命令重写。</span><span class="token comment"># 因为Redis总是使用最后解析的配置行最为配置指令的值, 你最好在这个文件的开头配置includes来</span><span class="token comment"># 避免它在运行时重写配置。</span><span class="token comment"># 如果相反你想用includes的配置覆盖原来的配置，你最好在该文件的最后使用include</span><span class="token comment">#</span><span class="token comment"># include /path/to/local.conf</span><span class="token comment"># include /path/to/other.conf</span><span class="token comment">################################ GENERAL  #####################################</span><span class="token comment"># 默认Rdis不会作为守护进程运行。如果需要的话配置成'yes'</span><span class="token comment"># 注意配置成守护进程后Redis会将进程号写入文件/var/run/redis.pid</span>daemonize no<span class="token comment"># 当以守护进程方式运行时，默认Redis会把进程ID写到 /var/run/redis.pid。你可以在这里修改路径。</span>pidfile /var/run/redis.pid<span class="token comment"># 接受连接的特定端口，默认是6379</span><span class="token comment"># 如果端口设置为0，Redis就不会监听TCP套接字。</span>port <span class="token number">6379</span><span class="token comment"># TCP listen() backlog.</span><span class="token comment">#</span><span class="token comment"># 在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。注意Linux内核默默地将这个值减小</span><span class="token comment"># 到/proc/sys/net/core/somaxconn的值，所以需要确认增大somaxconn和tcp_max_syn_backlog</span><span class="token comment"># 两个值来达到想要的效果。</span>tcp-backlog <span class="token number">511</span><span class="token comment"># 默认Redis监听服务器上所有可用网络接口的连接。可以用"bind"配置指令跟一个或多个ip地址来实现</span><span class="token comment"># 监听一个或多个网络接口</span><span class="token comment">#</span><span class="token comment"># 示例:</span><span class="token comment">#</span><span class="token comment"># bind 192.168.1.100 10.0.0.1</span><span class="token comment"># bind 127.0.0.1</span><span class="token comment"># 指定用来监听Unix套套接字的路径。没有默认值， 所以在没有指定的情况下Redis不会监听Unix套接字</span><span class="token comment">#</span><span class="token comment"># unixsocket /tmp/redis.sock</span><span class="token comment"># unixsocketperm 755</span><span class="token comment"># 一个客户端空闲多少秒后关闭连接。(0代表禁用，永不关闭)</span><span class="token function">timeout</span> <span class="token number">0</span><span class="token comment"># TCP keepalive.</span><span class="token comment">#</span><span class="token comment"># 如果非零，则设置SO_KEEPALIVE选项来向空闲连接的客户端发送ACK，由于以下两个原因这是很有用的：</span><span class="token comment">#</span><span class="token comment"># 1）能够检测无响应的对端</span><span class="token comment"># 2）让该连接中间的网络设备知道这个连接还存活</span><span class="token comment">#</span><span class="token comment"># 在Linux上，这个指定的值(单位：秒)就是发送ACK的时间间隔。</span><span class="token comment"># 注意：要关闭这个连接需要两倍的这个时间值。</span><span class="token comment"># 在其他内核上这个时间间隔由内核配置决定</span><span class="token comment">#</span><span class="token comment"># 这个选项的一个合理值是60秒</span>tcp-keepalive <span class="token number">0</span><span class="token comment"># 指定服务器调试等级</span><span class="token comment"># 可能值：</span><span class="token comment"># debug （大量信息，对开发/测试有用）</span><span class="token comment"># verbose （很多精简的有用信息，但是不像debug等级那么多）</span><span class="token comment"># notice （适量的信息，基本上是你生产环境中需要的）</span><span class="token comment"># warning （只有很重要/严重的信息会记录下来）</span>loglevel notice<span class="token comment"># 指明日志文件名。也可以使用"stdout"来强制让Redis把日志信息写到标准输出上。</span><span class="token comment"># 注意:如果Redis以守护进程方式运行，而设置日志显示到标准输出的话，日志会发送到/dev/null</span>logfile <span class="token string">""</span><span class="token comment"># 要使用系统日志记录器，只要设置 "syslog-enabled" 为 "yes" 就可以了。</span><span class="token comment"># 然后根据需要设置其他一些syslog参数就可以了。</span><span class="token comment"># syslog-enabled no</span><span class="token comment"># 指明syslog身份</span><span class="token comment"># syslog-ident redis</span><span class="token comment"># 指明syslog的设备。必须是user或LOCAL0 ~ LOCAL7之一。</span><span class="token comment"># syslog-facility local0</span><span class="token comment"># 设置数据库个数。默认数据库是 DB 0，</span><span class="token comment"># 可以通过select &lt;dbid&gt;  (0 &lt;= dbid &lt;= 'databases' - 1 ）来为每个连接使用不同的数据库。</span>databases <span class="token number">16</span><span class="token comment">################################ SNAPSHOTTING  ################################</span><span class="token comment">#</span><span class="token comment"># 把数据库存到磁盘上:</span><span class="token comment">#</span><span class="token comment">#   save &lt;seconds&gt; &lt;changes&gt;</span><span class="token comment">#   </span><span class="token comment">#   会在指定秒数和数据变化次数之后把数据库写到磁盘上。</span><span class="token comment">#</span><span class="token comment">#   下面的例子将会进行把数据写入磁盘的操作:</span><span class="token comment">#   900秒（15分钟）之后，且至少1次变更</span><span class="token comment">#   300秒（5分钟）之后，且至少10次变更</span><span class="token comment">#   60秒之后，且至少10000次变更</span><span class="token comment">#</span><span class="token comment">#   注意：你要想不写磁盘的话就把所有 "save" 设置注释掉就行了。</span><span class="token comment">#</span><span class="token comment">#   通过添加一条带空字符串参数的save指令也能移除之前所有配置的save指令</span><span class="token comment">#   像下面的例子：</span><span class="token comment">#   save "" </span>save <span class="token number">900</span> <span class="token number">1</span>save <span class="token number">300</span> <span class="token number">10</span>save <span class="token number">60</span> <span class="token number">10000</span><span class="token comment"># 默认如果开启RDB快照(至少一条save指令)并且最新的后台保存失败，Redis将会停止接受写操作</span><span class="token comment"># 这将使用户知道数据没有正确的持久化到硬盘，否则可能没人注意到并且造成一些灾难。</span><span class="token comment">#</span><span class="token comment"># 如果后台保存进程能重新开始工作，Redis将自动允许写操作</span><span class="token comment">#</span><span class="token comment"># 然而如果你已经部署了适当的Redis服务器和持久化的监控，你可能想关掉这个功能以便于即使是</span><span class="token comment"># 硬盘，权限等出问题了Redis也能够像平时一样正常工作，</span>stop-writes-on-bgsave-error <span class="token function">yes</span><span class="token comment"># 当导出到 .rdb 数据库时是否用LZF压缩字符串对象？</span><span class="token comment"># 默认设置为 "yes"，因为几乎在任何情况下它都是不错的。</span><span class="token comment"># 如果你想节省CPU的话你可以把这个设置为 "no"，但是如果你有可压缩的key和value的话，</span><span class="token comment"># 那数据文件就会更大了。</span>rdbcompression <span class="token function">yes</span><span class="token comment"># 因为版本5的RDB有一个CRC64算法的校验和放在了文件的最后。这将使文件格式更加可靠但在</span><span class="token comment"># 生产和加载RDB文件时，这有一个性能消耗(大约10%)，所以你可以关掉它来获取最好的性能。</span><span class="token comment">#</span><span class="token comment"># 生成的关闭校验的RDB文件有一个0的校验和，它将告诉加载代码跳过检查</span>rdbchecksum <span class="token function">yes</span><span class="token comment"># 持久化数据库的文件名</span>dbfilename dump.rdb<span class="token comment"># 工作目录</span><span class="token comment">#</span><span class="token comment"># 数据库会写到这个目录下，文件名就是上面的 "dbfilename" 的值。</span><span class="token comment"># </span><span class="token comment"># 累加文件也放这里。</span><span class="token comment"># </span><span class="token comment"># 注意你这里指定的必须是目录，不是文件名。</span><span class="token function">dir</span> ./<span class="token comment">################################# REPLICATION #################################</span><span class="token comment"># 主从同步。通过 slaveof 指令来实现Redis实例的备份。</span><span class="token comment"># 注意，这里是本地从远端复制数据。也就是说，本地可以有不同的数据库文件、绑定不同的IP、监听</span><span class="token comment"># 不同的端口。</span><span class="token comment">#</span><span class="token comment"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span><span class="token comment"># 如果master设置了密码保护（通过 "requirepass" 选项来配置），那么slave在开始同步之前必须</span><span class="token comment"># 进行身份验证，否则它的同步请求会被拒绝。</span><span class="token comment">#</span><span class="token comment"># masterauth &lt;master-password&gt;</span><span class="token comment"># 当一个slave失去和master的连接，或者同步正在进行中，slave的行为有两种可能：</span><span class="token comment">#</span><span class="token comment"># 1) 如果 slave-serve-stale-data 设置为 "yes" (默认值)，slave会继续响应客户端请求，</span><span class="token comment">#    可能是正常数据，也可能是还没获得值的空数据。</span><span class="token comment"># 2) 如果 slave-serve-stale-data 设置为 "no"，slave会回复"正在从master同步</span><span class="token comment">#   （SYNC with master in progress）"来处理各种请求，除了 INFO 和 SLAVEOF 命令。</span><span class="token comment">#</span>slave-serve-stale-data <span class="token function">yes</span><span class="token comment"># 你可以配置salve实例是否接受写操作。可写的slave实例可能对存储临时数据比较有用(因为写入salve</span><span class="token comment"># 的数据在同master同步之后将很容被删除)，但是如果客户端由于配置错误在写入时也可能产生一些问题。</span><span class="token comment">#</span><span class="token comment"># 从Redis2.6默认所有的slave为只读</span><span class="token comment">#</span><span class="token comment"># 注意:只读的slave不是为了暴露给互联网上不可信的客户端而设计的。它只是一个防止实例误用的保护层。</span><span class="token comment"># 一个只读的slave支持所有的管理命令比如config,debug等。为了限制你可以用'rename-command'来</span><span class="token comment"># 隐藏所有的管理和危险命令来增强只读slave的安全性</span>slave-read-only <span class="token function">yes</span><span class="token comment"># slave根据指定的时间间隔向master发送ping请求。</span><span class="token comment"># 时间间隔可以通过 repl_ping_slave_period 来设置。</span><span class="token comment"># 默认10秒。</span><span class="token comment">#</span><span class="token comment"># repl-ping-slave-period 10</span><span class="token comment"># 以下选项设置同步的超时时间</span><span class="token comment">#</span><span class="token comment"># 1）slave在与master SYNC期间有大量数据传输，造成超时</span><span class="token comment"># 2）在slave角度，master超时，包括数据、ping等</span><span class="token comment"># 3）在master角度，slave超时，当master发送REPLCONF ACK pings</span><span class="token comment"># </span><span class="token comment"># 确保这个值大于指定的repl-ping-slave-period，否则在主从间流量不高时每次都会检测到超时</span><span class="token comment">#</span><span class="token comment"># repl-timeout 60</span><span class="token comment"># 是否在slave套接字发送SYNC之后禁用 TCP_NODELAY ？</span><span class="token comment">#</span><span class="token comment"># 如果你选择“yes”Redis将使用更少的TCP包和带宽来向slaves发送数据。但是这将使数据传输到slave</span><span class="token comment"># 上有延迟，Linux内核的默认配置会达到40毫秒</span><span class="token comment">#</span><span class="token comment"># 如果你选择了 "no" 数据传输到salve的延迟将会减少但要使用更多的带宽</span><span class="token comment">#</span><span class="token comment"># 默认我们会为低延迟做优化，但高流量情况或主从之间的跳数过多时，把这个选项设置为“yes”</span><span class="token comment"># 是个不错的选择。</span>repl-disable-tcp-nodelay no<span class="token comment"># 设置数据备份的backlog大小。backlog是一个slave在一段时间内断开连接时记录salve数据的缓冲，</span><span class="token comment"># 所以一个slave在重新连接时，不必要全量的同步，而是一个增量同步就足够了，将在断开连接的这段</span><span class="token comment"># 时间内slave丢失的部分数据传送给它。</span><span class="token comment">#</span><span class="token comment"># 同步的backlog越大，slave能够进行增量同步并且允许断开连接的时间就越长。</span><span class="token comment">#</span><span class="token comment"># backlog只分配一次并且至少需要一个slave连接</span><span class="token comment">#</span><span class="token comment"># repl-backlog-size 1mb</span><span class="token comment"># 当master在一段时间内不再与任何slave连接，backlog将会释放。以下选项配置了从最后一个</span><span class="token comment"># slave断开开始计时多少秒后，backlog缓冲将会释放。</span><span class="token comment">#</span><span class="token comment"># 0表示永不释放backlog</span><span class="token comment">#</span><span class="token comment"># repl-backlog-ttl 3600</span><span class="token comment"># slave的优先级是一个整数展示在Redis的Info输出中。如果master不再正常工作了，哨兵将用它来</span><span class="token comment"># 选择一个slave提升=升为master。</span><span class="token comment">#</span><span class="token comment"># 优先级数字小的salve会优先考虑提升为master，所以例如有三个slave优先级分别为10，100，25，</span><span class="token comment"># 哨兵将挑选优先级最小数字为10的slave。</span><span class="token comment">#</span><span class="token comment"># 0作为一个特殊的优先级，标识这个slave不能作为master，所以一个优先级为0的slave永远不会被</span><span class="token comment"># 哨兵挑选提升为master</span><span class="token comment">#</span><span class="token comment"># 默认优先级为100</span>slave-priority <span class="token number">100</span><span class="token comment"># 如果master少于N个延时小于等于M秒的已连接slave，就可以停止接收写操作。</span><span class="token comment">#</span><span class="token comment"># N个slave需要是“oneline”状态</span><span class="token comment">#</span><span class="token comment"># 延时是以秒为单位，并且必须小于等于指定值，是从最后一个从slave接收到的ping（通常每秒发送）</span><span class="token comment"># 开始计数。</span><span class="token comment">#</span><span class="token comment"># This option does not GUARANTEES that N replicas will accept the write, but</span><span class="token comment"># will limit the window of exposure for lost writes in case not enough slaves</span><span class="token comment"># are available, to the specified number of seconds.</span><span class="token comment">#</span><span class="token comment"># 例如至少需要3个延时小于等于10秒的slave用下面的指令：</span><span class="token comment">#</span><span class="token comment"># min-slaves-to-write 3</span><span class="token comment"># min-slaves-max-lag 10</span><span class="token comment">#</span><span class="token comment"># 两者之一设置为0将禁用这个功能。</span><span class="token comment">#</span><span class="token comment"># 默认 min-slaves-to-write 值是0（该功能禁用）并且 min-slaves-max-lag 值是10。</span><span class="token comment">################################## SECURITY ###################################</span><span class="token comment"># 要求客户端在处理任何命令时都要验证身份和密码。</span><span class="token comment"># 这个功能在有你不信任的其它客户端能够访问redis服务器的环境里非常有用。</span><span class="token comment">#</span><span class="token comment"># 为了向后兼容的话这段应该注释掉。而且大多数人不需要身份验证(例如:它们运行在自己的服务器上)</span><span class="token comment"># </span><span class="token comment"># 警告：因为Redis太快了，所以外面的人可以尝试每秒150k的密码来试图破解密码。这意味着你需要</span><span class="token comment"># 一个高强度的密码，否则破解太容易了。</span><span class="token comment">#</span><span class="token comment"># requirepass foobared</span><span class="token comment"># 命令重命名</span><span class="token comment">#</span><span class="token comment"># 在共享环境下，可以为危险命令改变名字。比如，你可以为 CONFIG 改个其他不太容易猜到的名字，</span><span class="token comment"># 这样内部的工具仍然可以使用，而普通的客户端将不行。</span><span class="token comment">#</span><span class="token comment"># 例如：</span><span class="token comment">#</span><span class="token comment"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span><span class="token comment">#</span><span class="token comment"># 也可以通过改名为空字符串来完全禁用一个命令</span><span class="token comment">#</span><span class="token comment"># rename-command CONFIG ""</span><span class="token comment">#</span><span class="token comment"># 请注意：改变命令名字被记录到AOF文件或被传送到从服务器可能产生问题。</span><span class="token comment">################################### LIMITS ####################################</span><span class="token comment"># 设置最多同时连接的客户端数量。默认这个限制是10000个客户端，然而如果Redis服务器不能配置</span><span class="token comment"># 处理文件的限制数来满足指定的值，那么最大的客户端连接数就被设置成当前文件限制数减32（因</span><span class="token comment"># 为Redis服务器保留了一些文件描述符作为内部使用）</span><span class="token comment">#</span><span class="token comment"># 一旦达到这个限制，Redis会关闭所有新连接并发送错误'max number of clients reached'</span><span class="token comment">#</span><span class="token comment"># maxclients 10000</span><span class="token comment"># 不要用比设置的上限更多的内存。一旦内存使用达到上限，Redis会根据选定的回收策略（参见：</span><span class="token comment"># maxmemmory-policy）删除key</span><span class="token comment">#</span><span class="token comment"># 如果因为删除策略Redis无法删除key，或者策略设置为 "noeviction"，Redis会回复需要更</span><span class="token comment"># 多内存的错误信息给命令。例如，SET,LPUSH等等，但是会继续响应像Get这样的只读命令。</span><span class="token comment">#</span><span class="token comment"># 在使用Redis作为LRU缓存，或者为实例设置了硬性内存限制的时候（使用 "noeviction" 策略）</span><span class="token comment"># 的时候，这个选项通常事很有用的。</span><span class="token comment">#</span><span class="token comment"># 警告：当有多个slave连上达到内存上限的实例时，master为同步slave的输出缓冲区所需</span><span class="token comment"># 内存不计算在使用内存中。这样当驱逐key时，就不会因网络问题 / 重新同步事件触发驱逐key</span><span class="token comment"># 的循环，反过来slaves的输出缓冲区充满了key被驱逐的DEL命令，这将触发删除更多的key，</span><span class="token comment"># 直到这个数据库完全被清空为止</span><span class="token comment"># </span><span class="token comment"># 总之...如果你需要附加多个slave，建议你设置一个稍小maxmemory限制，这样系统就会有空闲</span><span class="token comment"># 的内存作为slave的输出缓存区(但是如果最大内存策略设置为"noeviction"的话就没必要了)</span><span class="token comment">#</span><span class="token comment"># maxmemory &lt;bytes&gt;</span><span class="token comment"># 最大内存策略：如果达到内存限制了，Redis如何选择删除key。你可以在下面五个行为里选：</span><span class="token comment"># </span><span class="token comment"># volatile-lru -&gt; 根据LRU算法生成的过期时间来删除。</span><span class="token comment"># allkeys-lru -&gt; 根据LRU算法删除任何key。</span><span class="token comment"># volatile-random -&gt; 根据过期设置来随机删除key。 </span><span class="token comment"># allkeys-&gt;random -&gt; 无差别随机删。 </span><span class="token comment"># volatile-ttl -&gt; 根据最近过期时间来删除（辅以TTL） </span><span class="token comment"># noeviction -&gt; 谁也不删，直接在写操作时返回错误。</span><span class="token comment"># </span><span class="token comment"># 注意：对所有策略来说，如果Redis找不到合适的可以删除的key都会在写操作时返回一个错误。</span><span class="token comment">#</span><span class="token comment">#       目前为止涉及的命令：set setnx setex append</span><span class="token comment">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><span class="token comment">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><span class="token comment">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><span class="token comment">#       getset mset msetnx exec sort</span><span class="token comment">#</span><span class="token comment"># 默认值如下：</span><span class="token comment">#</span><span class="token comment"># maxmemory-policy volatile-lru</span><span class="token comment"># LRU和最小TTL算法的实现都不是很精确，但是很接近（为了省内存），所以你可以用样本量做检测。</span><span class="token comment"># 例如：默认Redis会检查3个key然后取最旧的那个，你可以通过下面的配置指令来设置样本的个数。</span><span class="token comment">#</span><span class="token comment"># maxmemory-samples 3</span><span class="token comment">############################## APPEND ONLY MODE ###############################</span><span class="token comment"># 默认情况下，Redis是异步的把数据导出到磁盘上。这种模式在很多应用里已经足够好，但Redis进程</span><span class="token comment"># 出问题或断电时可能造成一段时间的写操作丢失(这取决于配置的save指令)。</span><span class="token comment">#</span><span class="token comment"># AOF是一种提供了更可靠的替代持久化模式，例如使用默认的数据写入文件策略（参见后面的配置）</span><span class="token comment"># 在遇到像服务器断电或单写情况下Redis自身进程出问题但操作系统仍正常运行等突发事件时，Redis</span><span class="token comment"># 能只丢失1秒的写操作。</span><span class="token comment">#</span><span class="token comment"># AOF和RDB持久化能同时启动并且不会有问题。</span><span class="token comment"># 如果AOF开启，那么在启动时Redis将加载AOF文件，它更能保证数据的可靠性。</span><span class="token comment">#</span><span class="token comment"># 请查看 http://redis.io/topics/persistence 来获取更多信息.</span>appendonly no<span class="token comment"># 纯累加文件名字（默认："appendonly.aof"）</span>appendfilename <span class="token string">"appendonly.aof"</span><span class="token comment"># fsync() 系统调用告诉操作系统把数据写到磁盘上，而不是等更多的数据进入输出缓冲区。</span><span class="token comment"># 有些操作系统会真的把数据马上刷到磁盘上；有些则会尽快去尝试这么做。</span><span class="token comment">#</span><span class="token comment"># Redis支持三种不同的模式：</span><span class="token comment">#</span><span class="token comment"># no：不要立刻刷，只有在操作系统需要刷的时候再刷。比较快。</span><span class="token comment"># always：每次写操作都立刻写入到aof文件。慢，但是最安全。</span><span class="token comment"># everysec：每秒写一次。折中方案。 </span><span class="token comment">#</span><span class="token comment"># 默认的 "everysec" 通常来说能在速度和数据安全性之间取得比较好的平衡。根据你的理解来</span><span class="token comment"># 决定，如果你能放宽该配置为"no" 来获取更好的性能(但如果你能忍受一些数据丢失，可以考虑使用</span><span class="token comment"># 默认的快照持久化模式)，或者相反，用“always”会比较慢但比everysec要更安全。</span><span class="token comment">#</span><span class="token comment"># 请查看下面的文章来获取更多的细节</span><span class="token comment"># http://antirez.com/post/redis-persistence-demystified.html </span><span class="token comment"># </span><span class="token comment"># 如果不能确定，就用 "everysec"</span><span class="token comment"># appendfsync always</span>appendfsync everysec<span class="token comment"># appendfsync no</span><span class="token comment"># 如果AOF的同步策略设置成 "always" 或者 "everysec"，并且后台的存储进程（后台存储或写入AOF</span><span class="token comment"># 日志）会产生很多磁盘I/O开销。某些Linux的配置下会使Redis因为 fsync()系统调用而阻塞很久。</span><span class="token comment"># 注意，目前对这个情况还没有完美修正，甚至不同线程的 fsync() 会阻塞我们同步的write(2)调用。</span><span class="token comment">#</span><span class="token comment"># 为了缓解这个问题，可以用下面这个选项。它可以在 BGSAVE 或 BGREWRITEAOF 处理时阻止fsync()。</span><span class="token comment"># </span><span class="token comment"># 这就意味着如果有子进程在进行保存操作，那么Redis就处于"不可同步"的状态。</span><span class="token comment"># 这实际上是说，在最差的情况下可能会丢掉30秒钟的日志数据。（默认Linux设定）</span><span class="token comment"># </span><span class="token comment"># 如果把这个设置成"yes"带来了延迟问题，就保持"no"，这是保存持久数据的最安全的方式。</span>no-appendfsync-on-rewrite no<span class="token comment"># 自动重写AOF文件</span><span class="token comment"># 如果AOF日志文件增大到指定百分比，Redis能够通过 BGREWRITEAOF 自动重写AOF日志文件。</span><span class="token comment"># </span><span class="token comment"># 工作原理：Redis记住上次重写时AOF文件的大小（如果重启后还没有写操作，就直接用启动时的AOF大小）</span><span class="token comment"># </span><span class="token comment"># 这个基准大小和当前大小做比较。如果当前大小超过指定比例，就会触发重写操作。你还需要指定被重写</span><span class="token comment"># 日志的最小尺寸，这样避免了达到指定百分比但尺寸仍然很小的情况还要重写。</span><span class="token comment">#</span><span class="token comment"># 指定百分比为0会禁用AOF自动重写特性。</span>auto-aof-rewrite-percentage <span class="token number">100</span>auto-aof-rewrite-min-size 64mb<span class="token comment">################################ LUA SCRIPTING  ###############################</span><span class="token comment"># Lua 脚本的最大执行时间，毫秒为单位</span><span class="token comment">#</span><span class="token comment"># 如果达到了最大的执行时间，Redis将要记录在达到最大允许时间之后一个脚本仍然在执行，并且将</span><span class="token comment"># 开始对查询进行错误响应。</span><span class="token comment">#</span><span class="token comment"># 当一个长时间运行的脚本超过了最大执行时间，只有 SCRIPT KILL 和 SHUTDOWN NOSAVE 两个</span><span class="token comment"># 命令可用。第一个可以用于停止一个还没有调用写命名的脚本。第二个是关闭服务器唯一方式，当</span><span class="token comment"># 写命令已经通过脚本开始执行，并且用户不想等到脚本的自然终止。</span><span class="token comment">#</span><span class="token comment"># 设置成0或者负值表示不限制执行时间并且没有任何警告</span>lua-time-limit <span class="token number">5000</span><span class="token comment">################################## SLOW LOG ###################################</span><span class="token comment"># Redis慢查询日志可以记录超过指定时间的查询。运行时间不包括各种I/O时间，例如：连接客户端，</span><span class="token comment"># 发送响应数据等，而只计算命令执行的实际时间（这只是线程阻塞而无法同时为其他请求服务的命令执</span><span class="token comment"># 行阶段）</span><span class="token comment"># </span><span class="token comment"># 你可以为慢查询日志配置两个参数:一个指明Redis的超时时间(单位为微秒)来记录超过这个时间的命令</span><span class="token comment"># 另一个是慢查询日志长度。当一个新的命令被写进日志的时候，最老的那个记录从队列中移除。</span><span class="token comment">#</span><span class="token comment"># 下面的时间单位是微秒，所以1000000就是1秒。注意，负数时间会禁用慢查询日志，而0则会强制记录</span><span class="token comment"># 所有命令。</span>slowlog-log-slower-than <span class="token number">10000</span><span class="token comment"># 这个长度没有限制。只是要主要会消耗内存。你可以通过 SLOWLOG RESET 来回收内存。</span>slowlog-max-len <span class="token number">128</span><span class="token comment">############################# Event notification ##############################</span><span class="token comment"># Redis 能通知 Pub/Sub 客户端关于键空间发生的事件</span><span class="token comment"># 这个功能文档位于http://redis.io/topics/keyspace-events</span><span class="token comment">#</span><span class="token comment"># 例如：如果键空间事件通知被开启，并且客户端对 0 号数据库的键 foo 执行 DEL 命令时，将通过</span><span class="token comment"># Pub/Sub发布两条消息：</span><span class="token comment"># PUBLISH __keyspace@0__:foo del</span><span class="token comment"># PUBLISH __keyevent@0__:del foo</span><span class="token comment">#</span><span class="token comment"># 可以在下表中选择Redis要通知的事件类型。事件类型由单个字符来标识：</span><span class="token comment">#</span><span class="token comment"># K    键空间通知，以__keyspace@&lt;db&gt;__为前缀</span><span class="token comment"># E    键事件通知，以__keysevent@&lt;db&gt;__为前缀</span><span class="token comment"># g    DEL , EXPIRE , RENAME 等类型无关的通用命令的通知, ...</span><span class="token comment"># $    String命令</span><span class="token comment"># l    List命令</span><span class="token comment"># s    Set命令</span><span class="token comment"># h    Hash命令</span><span class="token comment"># z    有序集合命令</span><span class="token comment"># x    过期事件（每次key过期时生成）</span><span class="token comment"># e    驱逐事件（当key在内存满了被清除时生成）</span><span class="token comment"># A    g$lshzxe的别名，因此”AKE”意味着所有的事件</span><span class="token comment">#</span><span class="token comment"># notify-keyspace-events 带一个由0到多个字符组成的字符串参数。空字符串意思是通知被禁用。</span><span class="token comment">#</span><span class="token comment"># 例子：启用List和通用事件通知：</span><span class="token comment"># notify-keyspace-events Elg</span><span class="token comment">#</span><span class="token comment"># 例子2：为了获取过期key的通知订阅名字为 __keyevent@__:expired 的频道，用以下配置</span><span class="token comment"># notify-keyspace-events Ex</span><span class="token comment">#</span><span class="token comment"># 默认所用的通知被禁用，因为用户通常不需要该特性，并且该特性会有性能损耗。</span><span class="token comment"># 注意如果你不指定至少K或E之一，不会发送任何事件。</span>notify-keyspace-events <span class="token string">""</span><span class="token comment">############################### ADVANCED CONFIG ###############################</span><span class="token comment"># 当hash只有少量的entry时，并且最大的entry所占空间没有超过指定的限制时，会用一种节省内存的</span><span class="token comment"># 数据结构来编码。可以通过下面的指令来设定限制</span>hash-max-ziplist-entries <span class="token number">512</span>hash-max-ziplist-value <span class="token number">64</span><span class="token comment"># 与hash似，数据元素较少的list，可以用另一种方式来编码从而节省大量空间。</span><span class="token comment"># 这种特殊的方式只有在符合下面限制时才可以用：</span>list-max-ziplist-entries <span class="token number">512</span>list-max-ziplist-value <span class="token number">64</span><span class="token comment"># set有一种特殊编码的情况：当set数据全是十进制64位有符号整型数字构成的字符串时。</span><span class="token comment"># 下面这个配置项就是用来设置set使用这种编码来节省内存的最大长度。</span>set-max-intset-entries <span class="token number">512</span><span class="token comment"># 与hash和list相似，有序集合也可以用一种特别的编码方式来节省大量空间。</span><span class="token comment"># 这种编码只适合长度和元素都小于下面限制的有序集合：</span>zset-max-ziplist-entries <span class="token number">128</span>zset-max-ziplist-value <span class="token number">64</span><span class="token comment"># HyperLogLog sparse representation bytes limit. The limit includes the</span><span class="token comment"># 16 bytes header. When an HyperLogLog using the sparse representation crosses</span><span class="token comment"># this limit, it is converted into the dense representation.</span><span class="token comment">#</span><span class="token comment"># A value greater than 16000 is totally useless, since at that point the</span><span class="token comment"># dense representation is more memory efficient.</span><span class="token comment"># </span><span class="token comment"># The suggested value is ~ 3000 in order to have the benefits of</span><span class="token comment"># the space efficient encoding without slowing down too much PFADD,</span><span class="token comment"># which is O(N) with the sparse encoding. The value can be raised to</span><span class="token comment"># ~ 10000 when CPU is not a concern, but space is, and the data set is</span><span class="token comment"># composed of many HyperLogLogs with cardinality in the 0 - 15000 range.</span>hll-sparse-max-bytes <span class="token number">3000</span><span class="token comment"># 启用哈希刷新，每100个CPU毫秒会拿出1个毫秒来刷新Redis的主哈希表（顶级键值映射表）。</span><span class="token comment"># redis所用的哈希表实现（见dict.c）采用延迟哈希刷新机制：你对一个哈希表操作越多，哈希刷新</span><span class="token comment"># 操作就越频繁；反之，如果服务器是空闲的，那么哈希刷新就不会完成，哈希表就会占用更多的一些</span><span class="token comment"># 内存而已。</span><span class="token comment"># </span><span class="token comment"># 默认是每秒钟进行10次哈希表刷新，用来刷新字典，然后尽快释放内存。</span><span class="token comment">#</span><span class="token comment"># 建议：</span><span class="token comment"># 如果你对延迟比较在意，不能够接受Redis时不时的对请求有2毫秒的延迟的话，就用</span><span class="token comment"># "activerehashing no"，如果不太在意延迟而希望尽快释放内存就设置"activerehashing yes"</span>activerehashing <span class="token function">yes</span><span class="token comment"># 客户端的输出缓冲区的限制，可用于强制断开那些因为某种原因从服务器读取数据的速度不够快的客户端，</span><span class="token comment"># （一个常见的原因是一个发布/订阅客户端消费消息的速度无法赶上生产它们的速度）</span><span class="token comment">#</span><span class="token comment"># 可以对三种不同的客户端设置不同的限制：</span><span class="token comment"># normal -&gt; 正常客户端</span><span class="token comment"># slave -&gt; slave和 MONITOR 客户端</span><span class="token comment"># pubsub -&gt; 至少订阅了一个pubsub channel或pattern的客户端</span><span class="token comment">#</span><span class="token comment"># 下面是每个client-output-buffer-limit语法:</span><span class="token comment"># client-output-buffer-limit &lt;class&gt;&lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span><span class="token comment"># 一旦达到硬限制客户端会立即被断开，或者达到软限制并持续达到指定的秒数（连续的）。</span><span class="token comment"># 例如，如果硬限制为32兆字节和软限制为16兆字节/10秒，客户端将会立即断开</span><span class="token comment"># 如果输出缓冲区的大小达到32兆字节，或客户端达到16兆字节并连续超过了限制10秒，就将断开连接。</span><span class="token comment">#</span><span class="token comment"># 默认normal客户端不做限制，因为他们在不主动请求时不接收数据（以推的方式），只有异步客户端</span><span class="token comment"># 可能会出现请求数据的速度比它可以读取的速度快的场景。</span><span class="token comment">#</span><span class="token comment"># pubsub和slave客户端会有一个默认值，因为订阅者和slaves以推的方式来接收数据</span><span class="token comment">#</span><span class="token comment"># 把硬限制和软限制都设置为0来禁用该功能</span>client-output-buffer-limit normal <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span>client-output-buffer-limit slave 256mb 64mb <span class="token number">60</span>client-output-buffer-limit pubsub 32mb 8mb <span class="token number">60</span><span class="token comment"># Redis调用内部函数来执行许多后台任务，如关闭客户端超时的连接，清除未被请求过的过期Key等等。</span><span class="token comment">#</span><span class="token comment"># 不是所有的任务都以相同的频率执行，但Redis依照指定的“hz”值来执行检查任务。</span><span class="token comment">#</span><span class="token comment"># 默认情况下，“hz”的被设定为10。提高该值将在Redis空闲时使用更多的CPU时，但同时当有多个key</span><span class="token comment"># 同时到期会使Redis的反应更灵敏，以及超时可以更精确地处理。</span><span class="token comment">#</span><span class="token comment"># 范围是1到500之间，但是值超过100通常不是一个好主意。</span><span class="token comment"># 大多数用户应该使用10这个默认值，只有在非常低的延迟要求时有必要提高到100。</span>hz <span class="token number">10</span><span class="token comment"># 当一个子进程重写AOF文件时，如果启用下面的选项，则文件每生成32M数据会被同步。为了增量式的</span><span class="token comment"># 写入硬盘并且避免大的延迟高峰这个指令是非常有用的</span>aof-rewrite-incremental-fsync <span class="token function">yes</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些网站和其他</title>
      <link href="posts/705c1a66.html"/>
      <url>posts/705c1a66.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>一些网站和github好用的开源库留存😄</p></blockquote><h2 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h2><p><a href="https://wangchujiang.com/linux-command/">https://wangchujiang.com/linux-command/</a> </p><p>  Linux的命令查询</p><p><a href="https://wangchujiang.com/tools/">https://wangchujiang.com/tools/</a>  </p><p>web用得上的工具集</p><p><a href="https://quickref.cn/">https://quickref.cn/</a> </p><p> 语言备忘速查表</p><p><a href="https://refactoringguru.cn/">https://refactoringguru.cn/</a> </p><p>设计模式详解</p><p><a href="https://blog.redis.com.cn/doc/">https://blog.redis.com.cn/doc/</a> </p><p>nginx中文文档-模块速查</p><p><a href="https://www.nginxedit.cn/">https://www.nginxedit.cn/</a></p><p>nginx 配置文件快速生成（不建议上手nginx马上用这个，可能会看不懂一些模块）</p><p><a href="https://forum.golangbridge.org/">https://forum.golangbridge.org/</a></p><p>go 语言论坛</p><p><a href="https://hellogithub.com/">https://hellogithub.com/</a></p><p>分享有趣、 入门级开源项目的平台</p><h2 id="开源库"><a href="#开源库" class="headerlink" title="开源库"></a>开源库</h2><p><a href="https://github.com/avelino/awesome-go">https://github.com/avelino/awesome-go</a>  </p><p>go的一些框架，开源库精选</p><p><a href="https://github.com/aws/aws-sdk-go">https://github.com/aws/aws-sdk-go</a> </p><p> aws的go语言sdk, (说句实话，aws的签名是我看过最复杂的，api文档也是最复杂的)</p><p><a href="https://github.com/go-pay/gopay">https://github.com/go-pay/gopay</a></p><p>国内支付的聚合支付的sdk</p><p><a href="https://github.com/Tencent/secguide">https://github.com/Tencent/secguide</a></p><p>面向开发人员梳理的代码安全指南</p><h3 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h3><p><img src="/medias/loading.gif" data-original="/posts/705c1a66/d6695j.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 其他 </tag>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="posts/5fddf106.html"/>
      <url>posts/5fddf106.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面, 整理了一些网上的git命令,不定时补充</p></blockquote><h1 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h1><h2 id="1-生成-SSH-Key"><a href="#1-生成-SSH-Key" class="headerlink" title="1. 生成 SSH Key"></a>1. 生成 SSH Key</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">ssh-keygen -t rsa -C <span class="token string">"youremail@xxx.com"</span><span class="token comment"># 输入之后直接两次回车即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>-t: 密钥类型, 可以选择 dsa | ecdsa | ed25519 | rsa;</p><p>-f: 密钥目录位置, 默认为当前用户home路径下的.ssh隐藏目录, 也就是~/.ssh/, 同时默认密钥文件名以id_rsa开头. 如果是root用户, 则在/root/.ssh/id_rsa, 若为其他用户, 则在/home/username/.ssh/id_rsa;</p><p>-C: 指定此密钥的备注信息, 需要配置多个免密登录时, 建议携带;</p><p>-N: 指定此密钥对的密码, 如果指定此参数, 则命令执行过程中就不会出现交互确认密码的信息了.</p><p>注意 github 在2022年3月后就不支持Ras密钥类型了  <a href="https://github.blog/2021-09-01-improving-git-protocol-security-github/">提高 GitHub 上的 Git 协议安全性 |GitHub 博客</a></p></blockquote><h2 id="2-查看-git-用户名和邮箱地址"><a href="#2-查看-git-用户名和邮箱地址" class="headerlink" title="2.查看 git 用户名和邮箱地址"></a>2.查看 git 用户名和邮箱地址</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 查看用户名</span>git config user.name<span class="token comment"># 查看邮箱地址</span>git config user.email<span class="token comment"># 查看配置信息</span>git config --list<span class="token comment"># 当前用户全局</span>git config --global<span class="token comment"># 当前系统全局</span>git config --system<span class="token comment"># 修改用户名</span>git config --global user.name <span class="token string">"username"</span><span class="token comment"># 修改邮箱地址</span>git config --global user.email <span class="token string">"email"</span><span class="token comment"># 重新输入账号密码</span>git config --system --unset credential.helper<span class="token comment"># 查看 git 配置信息</span>git config --list 或者 git config -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-初始化一个-git-仓库"><a href="#3-初始化一个-git-仓库" class="headerlink" title="3.初始化一个 git 仓库"></a>3.初始化一个 git 仓库</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-添加文件到-git-仓库"><a href="#4-添加文件到-git-仓库" class="headerlink" title="4.添加文件到 git 仓库"></a>4.添加文件到 git 仓库</h2><ol><li>添加文件到缓存区</li></ol><pre class="line-numbers language-git" data-language="git"><code class="language-git">git add &lt;filename&gt;<span class="token comment"># 比如添加 file.txt 文件： git add file.txt</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2.将缓存区文件提交到本地仓库</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">git commit -m <span class="token string">"add_file_message"</span><span class="token comment"># 比如提交 file.txt 文件：git commit -m "add file.txt"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="5-查看修改内容对比，提交到缓存区或者已经提交到本地仓库，使用-git-diff-会没有内容显示，也就是说只要修改了，在提交到缓存区之前使用-git-diff-才有用-（查看工作区的改变）"><a href="#5-查看修改内容对比，提交到缓存区或者已经提交到本地仓库，使用-git-diff-会没有内容显示，也就是说只要修改了，在提交到缓存区之前使用-git-diff-才有用-（查看工作区的改变）" class="headerlink" title="5.查看修改内容对比，提交到缓存区或者已经提交到本地仓库，使用 git diff 会没有内容显示，也就是说只要修改了，在提交到缓存区之前使用 git diff 才有用 （查看工作区的改变）"></a>5.查看修改内容对比，提交到缓存区或者已经提交到本地仓库，使用 git diff 会没有内容显示，也就是说只要修改了，在提交到缓存区之前使用 git diff 才有用 （查看工作区的改变）</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git diff<span class="token comment"># 还可以查看具体哪个文件做了什么修改</span><span class="token comment"># 比如查看 readme.txt 做了什么修改</span>git diff HEAD -- readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-查看当前仓库状态，任何时候都可以使用"><a href="#6-查看当前仓库状态，任何时候都可以使用" class="headerlink" title="6.查看当前仓库状态，任何时候都可以使用"></a>6.查看当前仓库状态，任何时候都可以使用</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7-查看提交日志"><a href="#7-查看提交日志" class="headerlink" title="7.查看提交日志"></a>7.查看提交日志</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 查看全部 </span>git log<span class="token comment"># 查看最后一次提交</span>git show<span class="token comment"># 查看倒数5条</span>git log -5<span class="token comment"># 简化日志显示方式，并含有提交版本号</span>git log --pretty=oneline<span class="token comment"># 比如：</span><span class="token comment"># $ git log --pretty=oneline</span><span class="token comment"># 44c9beb4c58543b89181829755be2c5e9781ba28 (HEAD -&gt; master) append GPL</span><span class="token comment"># 03112bdf101655c30df9b61e4bd325b2cbe3c090 add distributed</span><span class="token comment"># 8a1386bd0fe677bca99d5a4ef26e87772a3eca71 wrote a readme file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-回退版本"><a href="#8-回退版本" class="headerlink" title="8.回退版本"></a>8.回退版本</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 回退当前版本的上一个版本</span>git reset --hard HEAD^<span class="token comment"># 回退当前版本的上三个版本</span>git reset --hard HEAD^^^<span class="token comment"># 回退当前版本的上 100 个版本</span>git reset --hard HEAD~100<span class="token comment"># 回退指定版本，并将 「回退」动作作为一个版本提交</span>git revert &lt;commit id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-回退指定版本"><a href="#9-回退指定版本" class="headerlink" title="9. 回退指定版本"></a>9. 回退指定版本</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git reset --hard 版本号前几位<span class="token comment"># 比如回退到 以上查看日志中的 add distributed 这个提交版本</span>git reset --hard 44c9beb4c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-查看提交版本号-commit-id"><a href="#10-查看提交版本号-commit-id" class="headerlink" title="10. 查看提交版本号 commit id"></a>10. 查看提交版本号 commit id</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 要重返未来，用 `git reflog` 查看命令历史，以便确定要回到未来的哪个版本。</span>git reflog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="11-撤销修改"><a href="#11-撤销修改" class="headerlink" title="11.撤销修改"></a>11.撤销修改</h2><ol><li><strong>修改只在工作区，还没有添加到缓存区 （还没有 git add）</strong></li></ol><pre class="line-numbers language-git" data-language="git"><code class="language-git">git checkout -- filename<span class="token comment"># 比如 readme.txt 文件只是在工作区修改了，想回退到修改之前的提交的版本</span>git checkout -- readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>修改从工作区已经提交到了缓存区 （已经 git add）</strong></li></ol><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 将缓存区的修改回退到工作区</span>git reset HEAD filename<span class="token comment"># 比如 readme.txt 文件的修改已经提交到缓存区了，但是想撤销修改分为两步</span><span class="token comment"># 01.将缓存区的修改回退到工作区</span>git reset HEAD readme.txt<span class="token comment"># 02.将在工作区的修改回退到和上一个版本一样</span>git checkout -- readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>修改已经从缓存区提交到了本地仓库 （已经 git commit）</strong></li></ol><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 回退当前版本的上一个版本</span>git reset --hard HEAD^<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li><strong>将在暂存区的更改文件进行强制撤销。（想让之前已经提交到缓存区的文件覆盖工作区的文件）</strong></li></ol><pre class="line-numbers language-git" data-language="git"><code class="language-git">git checkout -f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5.** 命令 git clean 作用是清理项目，-f 是强制清理文件的设置，-d 选项命令连文件夹一并清除**</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">git clean -f -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li><strong>假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它：</strong></li></ol><pre class="line-numbers language-git" data-language="git"><code class="language-git">git fetch origin git reset --hard origin/master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="12-删除文件"><a href="#12-删除文件" class="headerlink" title="12.删除文件"></a>12.删除文件</h2><p><strong>1. 确实要删除该文件</strong></p><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 比如以 test.txt 为例子</span><span class="token comment"># 01 本地手动删除 test.txt 文件</span>rm test.txt 或者 rm -rf test.txt<span class="token comment"># 02 添加被删除的状态缓存区</span>git rm test.txt 或者 git add test.txt<span class="token comment"># 03 提交状态到本地仓库</span>git commit -m <span class="token string">"remove test.txt"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 工作区误删了文件</strong></p><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 01 工作区误删了 test.txt 文件</span>rm test.txt<span class="token comment"># 02 找回被误删的文件（撤销修改）</span>git checkout -- test.txt<span class="token comment"># 用版本库中的版本替换掉工作区的版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="13-创建分支并切换到该分支"><a href="#13-创建分支并切换到该分支" class="headerlink" title="13.创建分支并切换到该分支"></a>13.创建分支并切换到该分支</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git checkout -b juhaozero  或者 git switch -c juhaozero<span class="token comment"># 创建 juhaozero 分支并切换到 juhaozero 分支</span><span class="token comment"># 等同于以下两个命令</span><span class="token comment"># 创建 juhaozero 分支</span>git branch juhaozero<span class="token comment"># 切换到 juhaozero 分支</span>git checkout juhaozero  或者 git switch juhaozero<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-合并指定分支到当前分支"><a href="#14-合并指定分支到当前分支" class="headerlink" title="14.合并指定分支到当前分支"></a>14.合并指定分支到当前分支</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 比如当前位于 master 分支，欲将 juhaozero 分支合并到 master 分支</span>git merge juhaozero<span class="token comment"># 如果有冲突，解决步骤如下：</span><span class="token comment"># 01 先查看冲突文件</span>git status<span class="token comment"># 02 手动解决冲突文件</span><span class="token comment"># 03 再次合并分支</span>git merge juhaozero<span class="token comment"># 04 添加修改到缓存区</span>git add .<span class="token comment"># 05 提交到本地仓库</span>git commit -m <span class="token string">"merge fixed"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-查看分支的合并情况"><a href="#15-查看分支的合并情况" class="headerlink" title="15.查看分支的合并情况"></a>15.查看分支的合并情况</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git log --graph --pretty=oneline --abbrev-commit或者直接使用 git log --graph 命令可以看到分支合并图。<span class="token comment"># 设置别名查看所有的提交记录</span>git config --global alias.lg <span class="token string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="16-删除分支"><a href="#16-删除分支" class="headerlink" title="16.删除分支"></a>16.删除分支</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 合并代码之后删除分支 </span>git branch -d 分支名<span class="token comment"># 没有合并代码删除分支 </span>git branch -D 分支名<span class="token comment"># 删除远程分支（本地分支需要再次手动删除）</span>git push origin -d 分支名<span class="token comment"># 比如删除 juhaozero 分支</span>git branch -d juhaozero<span class="token comment"># 删除远程 juhaozero 分支</span>git push origin -d juhaozero<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="17-查看分支"><a href="#17-查看分支" class="headerlink" title="17.查看分支"></a>17.查看分支</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 只查看远程分支</span>git branch -r<span class="token comment"># 只查看本地分支</span>git branch<span class="token comment"># 查看所有远程分支和本地分支</span>git branch -a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="18-拉取远程分支并创建同名本地分支"><a href="#18-拉取远程分支并创建同名本地分支" class="headerlink" title="18.拉取远程分支并创建同名本地分支"></a>18.拉取远程分支并创建同名本地分支</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 方法一（此方法建立的本地分支和远程分支会有映射关系）</span>git checkout -b [本地分支名] origin/[远程分支名]举例：git checkout -b juhaozero origin/juhaozero<span class="token comment"># 方法二（此方法建立的本地分支和远程分支没有映射关系）</span>git fetch origin [远程分支名]:[本地分支名]举例：git fetch origin juhaozero:juhaozero<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="19-查看本地分支和远程分支的映射关系（远程有的分支而本地没有的分支不会出现）"><a href="#19-查看本地分支和远程分支的映射关系（远程有的分支而本地没有的分支不会出现）" class="headerlink" title="19.查看本地分支和远程分支的映射关系（远程有的分支而本地没有的分支不会出现）"></a>19.查看本地分支和远程分支的映射关系（远程有的分支而本地没有的分支不会出现）</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git branch -vv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="20-手动建立本地分支和远程分支的映射关系"><a href="#20-手动建立本地分支和远程分支的映射关系" class="headerlink" title="20.手动建立本地分支和远程分支的映射关系"></a>20.手动建立本地分支和远程分支的映射关系</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git branch -u origin/[分支名]或者git branch --set-upstream-to origin/[分支名]或者git branch --set-upstream-to=origin/[远程分支名] [本地分支名]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="21-推送分支"><a href="#21-推送分支" class="headerlink" title="21.推送分支"></a>21.推送分支</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git push -u origin &lt;branch name&gt; <span class="token comment"># 第一次推送的时候添加 -u 参数，给本地分支和远程分支创建连接关系，当第二次再次推送时，则不需要添加 -u 参数</span><span class="token comment"># 比如：推送 dev 分支</span>git push origin dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="22-查看远程库的信息"><a href="#22-查看远程库的信息" class="headerlink" title="22.查看远程库的信息"></a>22.查看远程库的信息</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git remote<span class="token comment"># 查看远程库更加详细的信息</span><span class="token comment"># 这里可以看到抓取和推送的 origin 的地址</span>git remote -v （小写的v）<span class="token comment"># 删除远程库连接</span>git remote rm &lt;origin name&gt;<span class="token comment"># eg：删除远程 origin 连接</span>git remote rm origin<span class="token comment"># 添加远程库连接</span>git remote add &lt;origin name&gt; &lt;ssh or http&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="23-三种状态命令比较"><a href="#23-三种状态命令比较" class="headerlink" title="23.三种状态命令比较"></a>23.三种状态命令比较</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>git add .</td><td>提交所有修改的和新建的数据暂存区 (提交当前文件夹下所有修改)</td></tr><tr><td>git add -u</td><td>提交所有被删除和修改的文件到数据暂存区（等同于git add -update）</td></tr><tr><td>git add -A</td><td>提交所有被删除、被替换、被修改和新增的文件到数据暂存区（等同于git add –all）</td></tr></tbody></table><h2 id="附一张常用命令表"><a href="#附一张常用命令表" class="headerlink" title="附一张常用命令表"></a>附一张常用命令表</h2><p><img src="/medias/loading.gif" data-original="/posts/5fddf106/011500266295799.jpg"></p><h3 id="暂时先到这里，有空再找其他来补充"><a href="#暂时先到这里，有空再找其他来补充" class="headerlink" title="暂时先到这里，有空再找其他来补充"></a>暂时先到这里，有空再找其他来补充</h3>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 常见命令</title>
      <link href="posts/59b529b7.html"/>
      <url>posts/59b529b7.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker-常见命令"><a href="#docker-常见命令" class="headerlink" title="docker 常见命令"></a>docker 常见命令</h1><ul><li>查看版本</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看详细版本</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看 docker 基本信息</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="镜像相关的命令"><a href="#镜像相关的命令" class="headerlink" title="镜像相关的命令"></a>镜像相关的命令</h2><p>镜像仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com</a></p><ul><li>查看本地已经安装的镜像</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>搜索指定镜像</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> search <span class="token operator">&lt;</span>image-name<span class="token operator">&gt;</span><span class="token comment"># 比如搜索 centos 镜像</span><span class="token function">docker</span> search centos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>拉取镜像</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull <span class="token operator">&lt;</span>image-name<span class="token operator">&gt;</span><span class="token comment"># 比如拉取 centos 镜像（将会拉取最新版本的镜像，即 latest 版本）</span><span class="token function">docker</span> pull centos<span class="token comment"># 拉取指定版本的镜像</span><span class="token function">docker</span> pull ubuntu:16.04<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>删除镜像</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> rmi <span class="token operator">&lt;</span>image-name<span class="token operator">&gt;</span><span class="token comment"># 比如删除 centos 镜像</span><span class="token function">docker</span> rmi centos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>删除所有的镜像</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> rmi <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> images <span class="token parameter variable">-q</span><span class="token variable">)</span></span><span class="token comment"># 查看所有镜像的镜像 id</span><span class="token function">docker</span> images <span class="token parameter variable">-q</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>更新镜像</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 更新镜像前，需要使用镜像创建一个容器</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> ubuntu:15.10 <span class="token function">bash</span><span class="token comment"># 在运行的容器内部使用 apt-get update 更新</span><span class="token comment"># 更新完毕之后，输入 exit 命令退出容器</span><span class="token comment"># 使用 docker commit 来提交容器副本</span><span class="token function">docker</span> commit <span class="token parameter variable">-m</span><span class="token operator">=</span><span class="token string">"has update"</span> <span class="token parameter variable">-a</span><span class="token operator">=</span><span class="token string">"juhaozero"</span> e218edb10161 juhaozero/ubuntu:v2<span class="token comment"># -m 表示提交的描述信息</span><span class="token comment"># -a 表示提交的镜像作者</span><span class="token comment"># e218edb10161 表示容器的 id</span><span class="token comment"># juhaozero/ubuntu:v2 表示指定要创建的目标镜像名</span><span class="token comment"># 查看新的镜像</span><span class="token function">docker</span> images<span class="token comment"># 使用新镜像 juhaozero/ubuntu:v2 来启动一个容器</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> juhaozero/ubuntu:v2 <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>构建镜像</li></ul><ol><li>vim  ~/glory/codes/book/demo/Dockerfile 填充以下内容，构建一个 centos 8 系统</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 指定使用哪个镜像源</span>FROM centos:8<span class="token comment"># 如果写了 3 次 RUN 那么将会在 docker 上新建 3 层，会导致镜像膨胀过大，下面这种方式只会创建 1 层镜像</span>RUN /bin/echo <span class="token string">'root:123456'</span> <span class="token operator">|</span> chpasswd<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">useradd</span> juhaozero<span class="token punctuation">;</span> <span class="token punctuation">\</span>/bin/echo <span class="token string">'juhaozero:123456'</span> <span class="token operator">|</span> chpasswd<span class="token punctuation">;</span> <span class="token punctuation">\</span>/bin/echo <span class="token parameter variable">-e</span> <span class="token string">"LANG=<span class="token entity" title="\&quot;">\"</span>en_US.UTF-8<span class="token entity" title="\&quot;">\"</span>"</span> <span class="token operator">&gt;</span> /etc/default/localEXPOSE <span class="token number">22</span>EXPOSE <span class="token number">80</span>CMD /usr/sbin/sshd <span class="token parameter variable">-D</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>开始构建镜像，注意不要在 <code>~/glory/codes/book/demo</code> 目录下放无用的文件，因为会打包所有该目录下的文件然后发送给 docker 引擎，如果文件过多会造成 build 过程缓慢</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -t 表示指定要创建的目标镜像名</span><span class="token comment"># ~/glory/codes/book/demo 表示 Dockerfile 文件所在的目录</span><span class="token function">docker</span> build <span class="token parameter variable">-t</span> juhaozero/centos:8.0 ~/glory/codes/book/demo<span class="token comment"># 查看已经构建好的镜像信息</span><span class="token function">docker</span> images<span class="token comment"># 使用新的镜像来创建新容器</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> juhaozero/centos:8.0 <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>设置镜像标签</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 先查看镜像</span>$ <span class="token function">docker</span> images                                                                   REPOSITORY            TAG                       IMAGE ID       CREATED          SIZEjuhaozero/centos           <span class="token number">8.0</span>                       594ab4747ed4   <span class="token number">14</span> minutes ago   210MB<span class="token comment"># 设置镜像标签</span>$ <span class="token function">docker</span> tag 594ab4747ed4 juhaozero1/centos1:8.1.1<span class="token comment"># 再次查看镜像信息会多一个标签</span>$ <span class="token function">docker</span> imagesREPOSITORY            TAG                       IMAGE ID       CREATED          SIZEjuhaozero/centos           <span class="token number">8.0</span>                       594ab4747ed4   <span class="token number">14</span> minutes ago   210MBjuhaozero1/centos1         <span class="token number">8.1</span>.1                     594ab4747ed4   <span class="token number">14</span> minutes ago   210MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="容器相关的命令"><a href="#容器相关的命令" class="headerlink" title="容器相关的命令"></a>容器相关的命令</h2><ul><li>查看容器的系统版本信息</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 进入容器后执行</span><span class="token function">cat</span> /proc/version<span class="token comment"># 比如会输出以下内容</span>Linux version <span class="token number">4.19</span>.121-linuxkit <span class="token punctuation">(</span>root@18b3f92ade35<span class="token punctuation">)</span> <span class="token punctuation">(</span>gcc version <span class="token number">9.2</span>.0 <span class="token punctuation">(</span>Alpine <span class="token number">9.2</span>.0<span class="token punctuation">))</span> <span class="token comment">#1 SMP Thu Jan 21 15:36:34 UTC 2021</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>查看所有的容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span><span class="token comment"># 或者使用以下命令，是一样的效果</span><span class="token function">docker</span> container <span class="token function">ls</span> <span class="token parameter variable">-a</span><span class="token comment"># 查看最后一次创建的容器</span><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-l</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>查看所有已经运行的容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">ps</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看容器端口映射</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> port <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看 docker 底层信息（比如：查看指定容器的 ip 地址）</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看 docker 容器的配置和状态信息</span><span class="token function">docker</span> inspect <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span> <span class="token comment"># 查看容器的 ip 地址</span><span class="token function">docker</span> inspect <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token function">grep</span> IPAddress<span class="token comment"># 比如查看容器 id 为 66204be9fe65 的容器所对应的 ip 地址</span><span class="token function">docker</span> inspect 66204be9fe65 <span class="token operator">|</span> <span class="token function">grep</span> IPAddress<span class="token comment"># 比如查看容器名称为 juhaozero 所对应的 ip 地址</span><span class="token function">docker</span> inspect juhaozero <span class="token operator">|</span> <span class="token function">grep</span> IPAddress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>创建容器并把镜像恢复到容器当中，且启动容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token punctuation">[</span>-i<span class="token punctuation">]</span><span class="token punctuation">[</span>-t<span class="token punctuation">]</span><span class="token punctuation">[</span>-v<span class="token punctuation">]</span><span class="token punctuation">[</span>--name<span class="token punctuation">]</span><span class="token punctuation">[</span>-d<span class="token punctuation">]</span><span class="token punctuation">[</span>-p<span class="token punctuation">]</span><span class="token comment"># -i 表示 interactive 交互式</span><span class="token comment"># -t 表示得到一个 terminal</span><span class="token comment"># --name 表示修改容器名称</span><span class="token comment"># -d 表示以守护进程的方式运行（默认不会进入容器，想要进入容器则需要使用 docker exec 命令）</span><span class="token comment"># -p 表示 **指定** 映射端口</span><span class="token comment"># -P （大写的字母 p ） 表示 **随机** 映射端口</span><span class="token comment"># /bin/bash 和 bash 等效</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token operator">&lt;</span>image-name<span class="token operator">&gt;</span> /bin/bash<span class="token comment"># 比如创建一个新容器并且进入 ubuntu:16.04 镜像</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> ubuntu:16.04 <span class="token function">bash</span><span class="token comment"># 或者</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> ubuntu:16.04 /bin/bash<span class="token comment"># 或者</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> ubuntu:16.04<span class="token comment"># 以 centos 镜像创建一个新容器，并修改新容器名称为 juhaozero-container</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> juhaozero-container centos <span class="token function">bash</span>  <span class="token comment"># 以守护进程的方式运行 （后台运行）</span><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> juhaozero-container centos  <span class="token comment"># 或者</span><span class="token function">docker</span> run <span class="token parameter variable">-di</span> <span class="token parameter variable">--name</span> juhaozero-container centos<span class="token comment"># 指定容器绑定的网络地址，这样我们就可以通过访问 127.0.0.1:5001 来访问容器的 5000 端口（默认绑定的都是 tcp 端口）</span><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">127.0</span>.0.1:5001:5000 centos:8.0 <span class="token function">bash</span><span class="token comment"># 如果需要绑定 udp 端口，则</span><span class="token comment"># （还可以进入容器就直接执行 python app.py 命令）</span><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">127.0</span>.0.1:5001:5000/udp centos:8.0 python app.py<span class="token comment"># 比如，安装 hyperf 镜像并启动容器</span><span class="token comment"># 如果 docker 启动时开启了 selinux-enabled 选项，容器内访问宿主机资源就会受限，所以启动容器时可以增加 --privileged -u root 选项</span><span class="token function">docker</span> run <span class="token parameter variable">--name</span> hyperf <span class="token punctuation">\</span><span class="token parameter variable">-v</span> /workspace/skeleton:/data/project <span class="token punctuation">\</span><span class="token parameter variable">-p</span> <span class="token number">9501</span>:9501 <span class="token parameter variable">-it</span> <span class="token punctuation">\</span><span class="token parameter variable">--privileged</span> <span class="token parameter variable">-u</span> root <span class="token punctuation">\</span><span class="token parameter variable">--entrypoint</span> /bin/sh <span class="token punctuation">\</span>hyperf/hyperf:7.4-alpine-v3.11-swoole<span class="token comment"># 如果需要开通多个端口时，可以参考</span><span class="token function">docker</span> run <span class="token parameter variable">--name</span> api_dfo_hyperf_ws <span class="token punctuation">\</span><span class="token parameter variable">-v</span> /Users/pudongping/glory/codes/dfo/api_dfo_hyperf:/api_dfo_hyperf <span class="token punctuation">\</span><span class="token parameter variable">-p</span> <span class="token number">9502</span>:9502 <span class="token punctuation">\</span><span class="token parameter variable">-p</span> <span class="token number">9503</span>:9503 <span class="token punctuation">\</span><span class="token parameter variable">-p</span> <span class="token number">9504</span>:9504 <span class="token punctuation">\</span><span class="token parameter variable">-p</span> <span class="token number">9505</span>:9505 <span class="token parameter variable">-it</span> <span class="token punctuation">\</span><span class="token parameter variable">--entrypoint</span> /bin/sh <span class="token punctuation">\</span>juhaozero/juhaozero_api_dfo:v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>启动容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> start <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span><span class="token comment"># 比如启动容器名称为 redis-juhaozero 的容器</span><span class="token function">docker</span> start redis-juhaozero<span class="token comment"># 比如启动容器 id 为 c8c0c770ac5b 的容器</span><span class="token function">docker</span> start c8c0c770ac5b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>直接进入已经创建的容器（不会启动容器）</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> start <span class="token parameter variable">-i</span> <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span><span class="token comment"># 比如进入容器 id 为 66204be9fe65 的容器</span><span class="token function">docker</span> start <span class="token parameter variable">-i</span> 66204be9fe65<span class="token comment"># 比如进入容器名称为 juhaozero 的容器</span><span class="token function">docker</span> start <span class="token parameter variable">-i</span> juhaozero<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>重启容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> restart <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span><span class="token comment"># 比如重启容器名称为 redis-juhaozero 的容器</span><span class="token function">docker</span> restart redis-juhaozero<span class="token comment"># 比如重启容器 id 为 c8c0c770ac5b 的容器</span><span class="token function">docker</span> restart c8c0c770ac5b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>进入已经运行中的容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span> <span class="token function">bash</span><span class="token comment"># 比如进入容器名称为 redis-juhaozero 的容器</span><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> redis-juhaozero <span class="token function">bash</span><span class="token comment"># 比如进入容器 id 为 c8c0c770ac5b 的容器</span><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> c8c0c770ac5b <span class="token function">bash</span><span class="token comment"># 进入容器之后执行 shell 命令或者执行 shell 脚本</span><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span>  <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span> /bin/sh <span class="token parameter variable">-c</span> <span class="token string">"while true; do echo hello world; sleep 1; done"</span><span class="token comment"># 比如进入容器 id 为 c8c0c770ac5b 的容器，并且进入容器后执行 `bash /portal_api_dfo_hyperf/server.sh restart` 脚本</span><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> c8c0c770ac5b /bin/sh <span class="token parameter variable">-c</span> <span class="token string">"bash /portal_api_dfo_hyperf/server.sh restart"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>停止容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> stop <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span><span class="token comment"># 比如停止容器名称为 redis-juhaozero 的容器</span><span class="token function">docker</span> stop redis-juhaozero<span class="token comment"># 比如停止容器 id 为 c8c0c770ac5b 的容器</span><span class="token function">docker</span> stop c8c0c770ac5b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>退出容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>删除容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">rm</span> <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span><span class="token comment"># 也可以加入 -f 参数，强制移除正在运行中的容器</span><span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> 1e560fca3906<span class="token comment"># 清理掉所有处于终止状态的容器</span><span class="token function">docker</span> container prune<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>修改容器名称</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">rename</span> <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>new-container-name<span class="token operator">&gt;</span><span class="token comment"># 比如将容器 redis-juhaozero 改名为 redis-tt</span><span class="token function">docker</span> <span class="token function">rename</span> redis-juhaozero redis-tt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>查看容器的标准输出</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> logs <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span><span class="token comment"># 比如查看容器 id 为 c8c0c770ac5b 的容器标准输出内容</span><span class="token function">docker</span> logs c8c0c770ac5b<span class="token comment"># 也可以加入 -f 参数，像使用 tail -f 一样来输出容器内部的标准输出</span><span class="token function">docker</span> logs <span class="token parameter variable">-f</span> c8c0c770ac5b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="容器与宿主机之间的文件或者目录拷贝"><a href="#容器与宿主机之间的文件或者目录拷贝" class="headerlink" title="容器与宿主机之间的文件或者目录拷贝"></a>容器与宿主机之间的文件或者目录拷贝</h2><ul><li>从宿主机拷贝文件到容器中</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">cp</span> <span class="token operator">&lt;</span>local-directory-or-file<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>container-name<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>container-directory-or-file<span class="token operator">&gt;</span><span class="token comment"># 比如将宿主机中的 /home/juhaozero/test.txt 文件拷贝到 centos1 容器中的 /test.txt</span><span class="token function">docker</span> <span class="token function">cp</span> /home/juhaozero/test.txt centos1:/test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>从容器拷贝到宿主机中</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">cp</span> <span class="token operator">&lt;</span>container-name<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>container-directory-or-file<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>local-directory<span class="token operator">&gt;</span><span class="token comment"># 比如将 centos1 容器中的 /test 目录拷贝到宿主机的 /home/juhaozero 目录下</span><span class="token function">docker</span> <span class="token function">cp</span> centos1:/test /home/juhaozero<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="目录挂载（创建容器的时候就需要进行目录挂载）"><a href="#目录挂载（创建容器的时候就需要进行目录挂载）" class="headerlink" title="目录挂载（创建容器的时候就需要进行目录挂载）"></a>目录挂载（创建容器的时候就需要进行目录挂载）</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-di</span> <span class="token parameter variable">-v</span> <span class="token operator">&lt;</span>local-directory<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>container-directory<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>image-name<span class="token operator">&gt;</span><span class="token comment"># 在 windows 下挂载（注意路径的书写方式）</span><span class="token comment"># 比如以 centos 镜像创建一个容器，并将本地 D 盘中的 juhaozero 目录，挂载到容器中的 /usr/local/demo 目录</span><span class="token function">docker</span> run <span class="token parameter variable">-di</span> <span class="token parameter variable">-v</span> d:<span class="token punctuation">\</span>juhaozero:/usr/local/demo centos<span class="token comment"># 在 linux 下挂载</span><span class="token comment"># 比如以 centos 镜像创建一个容器，并将本地的 /home/juhaozero/juhaozero 目录，挂载到容器中的 /usr/local/demo 目录</span><span class="token function">docker</span> run <span class="token parameter variable">-di</span> <span class="token parameter variable">-v</span> /home/juhaozero/juhaozero:/usr/local/demo centos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h2><ul><li>导出容器快照</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">export</span> <span class="token operator">&lt;</span>container-id<span class="token operator">&gt;</span> <span class="token operator">&gt;</span> <span class="token operator">&lt;</span>your-backup-name.tar<span class="token operator">&gt;</span><span class="token comment"># 比如将容器 id 为 7691a814370e 的容器导出快照为 juhaozero.tar</span><span class="token function">docker</span> <span class="token builtin class-name">export</span> 7691a814370e <span class="token operator">&gt;</span> juhaozero.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>导入容器快照</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;</span>your-backup-name.tar<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token function">docker</span> <span class="token function">import</span> - <span class="token operator">&lt;</span>image-author-name<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>your-new-image-name<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>your-new-image-version<span class="token operator">&gt;</span><span class="token comment"># 比如将容器快照文件 juhaozero.tar 导入到 juhaozero-demo 镜像并定义 juhaozero-demo 镜像的作者为 juhaozero，版本号为 v1.0</span><span class="token function">cat</span> juhaozero.tar <span class="token operator">|</span> <span class="token function">docker</span> <span class="token function">import</span> - juhaozero/juhaozero-demo:v1.0<span class="token comment"># 此外，也可以通过指定 url 或者某个目录来导入</span><span class="token function">docker</span> <span class="token function">import</span> http://example.com/example-image.tgz example/image-repo:v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 密钥登录</title>
      <link href="posts/1c226d39.html"/>
      <url>posts/1c226d39.html</url>
      
        <content type="html"><![CDATA[<h2 id="何为密钥登录"><a href="#何为密钥登录" class="headerlink" title="何为密钥登录 ?"></a><strong>何为密钥登录 ?</strong></h2><p>SHH 密钥对通过<strong>加密算法</strong>生成一对密钥，默认采用 RSA 2048 位的加密方式，生成的密钥是一个对外界公开，称为公钥，另一个用户自己保留，称为私钥，这种方式可使服务器的登录认证更加安全可靠。<br>简单讲类似于门锁的结构，但这把门锁有其唯一性，服务器使用密钥登录，没有私钥任何人都无法直接登录，可以杜绝暴力破解威胁</p><table><thead><tr><th>常用参数</th><th>说明</th></tr></thead><tbody><tr><td>-t</td><td>指定生成密钥的类型，RSA和DSA(默认使用RSA算法 ) 算法有rsa1”(SSH-1) “rsa”(SSH-2) “dsa”(SSH-2)</td></tr><tr><td>-f</td><td>指定生成密钥的文件名，默认id_rsa（私钥id_rsa，公钥id_rsa.pub）</td></tr><tr><td>-P</td><td>提供旧密码，空表示不需要密码（-P ‘’）</td></tr><tr><td>-N</td><td>提供旧密码，空表示不需要密码（-P ‘’）</td></tr><tr><td>-b</td><td>指定密钥长度（bits），RSA最小要求768位，默认是2048位；DSA密钥必须是1024位（FIPS 1862标准规定）</td></tr><tr><td>-C</td><td>提供一个新注释</td></tr><tr><td>-R</td><td>hostname：从known_hosta（第一次连接时就会在家目录.ssh目录下生产该密钥文件）文件中删除所有属于hostname的密钥</td></tr></tbody></table><h2 id="生成密钥对并使用密钥认证登录"><a href="#生成密钥对并使用密钥认证登录" class="headerlink" title="生成密钥对并使用密钥认证登录"></a>生成密钥对并使用密钥认证登录</h2><h6 id="在Linux服务器上的-ssh目录下（-ssh文件夹为隐藏文件夹-ll-a-可查看）"><a href="#在Linux服务器上的-ssh目录下（-ssh文件夹为隐藏文件夹-ll-a-可查看）" class="headerlink" title="在Linux服务器上的 .ssh目录下（.ssh文件夹为隐藏文件夹 ll -a 可查看）"></a>在Linux服务器上的 .ssh目录下（.ssh文件夹为隐藏文件夹 ll -a 可查看）</h6><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#生成一个rsa算法加密的 2048位的密钥对</span>ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-b</span> <span class="token number">2048</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="如不需要指定密码，直接按三次确认即可"><a href="#如不需要指定密码，直接按三次确认即可" class="headerlink" title="如不需要指定密码，直接按三次确认即可"></a>如不需要指定密码，直接按三次确认即可</h6><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20210513202553923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70"></p><h6 id="ssh目录下会有一个-authorized-keys文件，没有自己创建即可"><a href="#ssh目录下会有一个-authorized-keys文件，没有自己创建即可" class="headerlink" title=".ssh目录下会有一个 authorized_keys文件，没有自己创建即可"></a>.ssh目录下会有一个 authorized_keys文件，没有自己创建即可</h6><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20210513202913870.png"></p><h6 id="下载私钥到自己电脑上！！！！"><a href="#下载私钥到自己电脑上！！！！" class="headerlink" title="下载私钥到自己电脑上！！！！"></a>下载私钥到自己电脑上！！！！</h6><h6 id="下载私钥到自己电脑上！！！！-1"><a href="#下载私钥到自己电脑上！！！！-1" class="headerlink" title="下载私钥到自己电脑上！！！！"></a>下载私钥到自己电脑上！！！！</h6><h6 id="下载私钥到自己电脑上！！！！-2"><a href="#下载私钥到自己电脑上！！！！-2" class="headerlink" title="下载私钥到自己电脑上！！！！"></a>下载私钥到自己电脑上！！！！</h6><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#将生成的公钥复制到该文件下</span><span class="token function">cat</span> id_rsa.pub <span class="token operator">&gt;&gt;</span> authorized_keys<span class="token comment">#为文件和文件夹设置权限，部分权限不足可致无法登录</span><span class="token function">chmod</span> <span class="token number">700</span> .ssh<span class="token function">chmod</span> <span class="token number">600</span> .ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="ssh服务端配置sshd-config"><a href="#ssh服务端配置sshd-config" class="headerlink" title="ssh服务端配置sshd_config"></a>ssh服务端配置sshd_config</h6><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">vim <span class="token operator">/</span>etc/ssh/sshd_config  <span class="token comment">#禁用SSH密码验证</span>PasswordAuthentication no<span class="token comment">#是否允许公钥认证。仅可以用于SSH-2。默认值为"yes"。</span>PubkeyAuthentication yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="在自己的Linux远程服务端选择密钥连接。选择私钥即可"><a href="#在自己的Linux远程服务端选择密钥连接。选择私钥即可" class="headerlink" title="在自己的Linux远程服务端选择密钥连接。选择私钥即可"></a>在自己的Linux远程服务端选择密钥连接。选择私钥即可</h5><p>==需保证创建密钥对和登录是同一个用户，不同用户将公钥复制到该用户的.ssh文件夹下的authorized_keys 即可 ==</p><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20210513204410393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70"></p><p>参考文章<br><a href="https://blog.51cto.com/u_13691477/2121696">ssh-keygen常用参数详解</a><br><a href="https://blog.csdn.net/baidu_35287211/article/details/82115016">ssh密钥登录linux</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 命令</title>
      <link href="posts/85903493.html"/>
      <url>posts/85903493.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h5 id="目录切换"><a href="#目录切换" class="headerlink" title="目录切换"></a>目录切换</h5><p><code>cd .</code>  当前目录<br><code>cd ..</code> 返回上一级目录<br><code>cd-</code>返回上一次目录<br><code>cd~</code> 返回当前主目录</p><h5 id="创建目录和查看目录"><a href="#创建目录和查看目录" class="headerlink" title="创建目录和查看目录"></a>创建目录和查看目录</h5><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>mkdir 目录名</td><td>创建目录</td></tr><tr><td>mkdir [-p] 目录名</td><td>如果父目录不存在先创建父目录，之后再创建子目录</td></tr><tr><td>ls</td><td>显示当前目录下的文件和目录</td></tr><tr><td>ls-l</td><td>以详细的方式显示当前目录下的文件和目录</td></tr><tr><td>ls-a</td><td>显示当前目录下所有的文件和目录，包含隐藏的文件和目录。</td></tr></tbody></table><h5 id="重命名、移动、复制"><a href="#重命名、移动、复制" class="headerlink" title="重命名、移动、复制"></a>重命名、移动、复制</h5><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>mv 旧文件名 新文件名</td><td>重命名文件名/</td></tr><tr><td>mv  源目录  目标目录</td><td>移动（存在文件名则移动，不存在则重命名）</td></tr><tr><td>cp -r  源文件或目录 目标目录</td><td>所有的文件全部复制</td></tr></tbody></table><h5 id="删除（谨慎操作）"><a href="#删除（谨慎操作）" class="headerlink" title="删除（谨慎操作）"></a>删除（谨慎操作）</h5><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>rm -r 目录名称</td><td>删除目录，可以同时指定多个（删除前需要确定）</td></tr><tr><td>rm -r 文件或目录</td><td>名称 强制删除，删除前不会有提问</td></tr><tr><td>rm -rf 文件或目录名称</td><td>强制删除文件或目录</td></tr><tr><td>rm -rf /*</td><td>删除所有的文件或目录（千万不要用）</td></tr><tr><td><img src="/medias/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cDovLzViMDk4OGU1OTUyMjUuY2RuLnNvaHVjcy5jb20vaW1hZ2VzLzIwMTgwOTIyLzIxODlmOTE5MTYzMTRhZmFhYzQ2ZWJhNmU2MWUzNTU2LmpwZWc?x-oss-process=image/format,png" alt="在这里插入图片描述"></td><td></td></tr></tbody></table><h4 id="创建文件、查看文件内容"><a href="#创建文件、查看文件内容" class="headerlink" title="创建文件、查看文件内容"></a>创建文件、查看文件内容</h4><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>touch  文件</td><td>创建一个或多个文件</td></tr><tr><td>cat 文件名称</td><td>查看文件所有的内容</td></tr><tr><td>more 文件名称</td><td>查看文件所有的内容，可以分屏显示</td></tr><tr><td>head 文件名称</td><td>查看文件前 10 行</td></tr><tr><td>head -n  行数  文件名</td><td>查看前面指定的行数</td></tr><tr><td>tail  文件名</td><td>查看文件后 10 行</td></tr><tr><td>tail -n  行数  文件名</td><td>查看文件后指定的行数</td></tr><tr><td>less  文件名</td><td>查看文件所有的内容</td></tr><tr><td>less -N 文件名</td><td>查看文件所有的内容（显示行数）</td></tr></tbody></table><h2 id="解压和打包压缩命令"><a href="#解压和打包压缩命令" class="headerlink" title="解压和打包压缩命令"></a>解压和打包压缩命令</h2><p> <strong>压缩</strong></p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>tar-c</td><td>创建打包文件</td></tr><tr><td>tar-v</td><td>打包文件</td></tr><tr><td>tar-z</td><td>压缩文件</td></tr><tr><td>tar-f</td><td>压缩文件名</td></tr><tr><td>tar -cvzf 新的文件名.tar.gz 打包的文件</td><td>打包并压缩文件并设置名字</td></tr></tbody></table><p><strong>解压</strong></p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>tar -x</td><td>解压指定文件</td></tr><tr><td>tar-v</td><td>显示解压详细过程</td></tr><tr><td>tar-f</td><td>指定解压的文件</td></tr><tr><td>tar-C</td><td>解压到指定目录下</td></tr><tr><td>tar -xvf 解压的文件  -C 解压的位置</td><td>解压到指定位置并展现详细过程</td></tr></tbody></table><h2 id="Vim命令"><a href="#Vim命令" class="headerlink" title="Vim命令"></a>Vim命令</h2><h5 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h5><p>可以<strong>移动光标、删除字符等操作</strong>，打开文件时即进入这个模式</p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>vim 文件名字</td><td>打开文件</td></tr><tr><td>i</td><td>在当前光标的前面插入字符</td></tr><tr><td>a</td><td>在当前光标的后面插入字符</td></tr><tr><td>o</td><td>在当前光标的下一行插入字符</td></tr><tr><td>yy</td><td>复制当前行</td></tr><tr><td>p</td><td>如果前面已经复制了，在当前下面粘贴</td></tr><tr><td>u</td><td>撤销</td></tr><tr><td>/</td><td>搜索文本</td></tr></tbody></table><h5 id="底行模式"><a href="#底行模式" class="headerlink" title="底行模式"></a>底行模式</h5><p>可以输入命令<strong>对编辑的文件进行查找，保存，退出等操作</strong></p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>wq</td><td>保存并退出</td></tr><tr><td>q!</td><td>不保存强制退出</td></tr><tr><td>wq!</td><td>强制保存退出</td></tr></tbody></table><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><p><strong>主机名配置</strong></p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>hostname</td><td>获取主机名</td></tr><tr><td>hostname 新主机名</td><td>修改主机名、单次有效</td></tr><tr><td>hostnamectl set -hostname 新主机名</td><td>修改主机名，永久有效</td></tr></tbody></table><p><strong>查询网络进程</strong></p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>netstat</td><td>显示网络状态</td></tr><tr><td>netstat -n</td><td>显示程序中的ip地址和端口号</td></tr><tr><td>netstat -t</td><td>只显示Tcp协议的连接</td></tr><tr><td>netstat -l</td><td>显示监听中的 Socket</td></tr><tr><td>netstat-p</td><td>显示程序的名字</td></tr><tr><td>netstat -nutlp</td><td>以上全部都显示</td></tr></tbody></table><p><strong>防火墙配置</strong></p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>systemctl status firewalld</td><td>查看防火墙的状态</td></tr><tr><td>systemctl start firewalld</td><td>开启防火墙</td></tr><tr><td>systemctl stop firewalld</td><td>关闭防火墙</td></tr><tr><td>systemctl enable firewalld</td><td>开机自启</td></tr><tr><td>systemctl disable firewalld</td><td>开机不自启</td></tr><tr><td>systemctl restart firewalld</td><td>重启防火墙</td></tr><tr><td>firewall-cmd –zone=public –add-port= 端口/tcp –permanent</td><td>开放端口允许外部连接</td></tr></tbody></table><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>pwd</td><td>打印当前的工作目录</td></tr><tr><td>ps-aux</td><td>显示当前用户的所有进程</td></tr><tr><td>kill -9 进程号</td><td>杀死进程</td></tr><tr><td>free -m</td><td>查看系统内存的使用情况</td></tr><tr><td>shutdown now</td><td>关闭服务器</td></tr><tr><td>reboot</td><td>重启服务器</td></tr></tbody></table><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>个人博客：<a href="https://juhaozero.github.io/"> juhaozero的博客 </a><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109205044873.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 入门</title>
      <link href="posts/49f1e1db.html"/>
      <url>posts/49f1e1db.html</url>
      
        <content type="html"><![CDATA[<h5 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h5><p>本来想年后再写，但遇上了肺炎的爆发，抽空乱写吧！大家出门记得戴口罩啊！！关于docker，这边也只学了个大概，凑合看吧！，有不对的地方欢迎指正</p><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><blockquote><p>Docker是一个开放源代码软件项目，让应用程序部署在软件货柜下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。</p></blockquote><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200106210850161.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "><br>之前我们部署项目是在Linux上部署的，而利用docker我们可以在docker上部署，而docker部署在Linux上，那Linux上可以部署多个docker，也就是说我们可以部署多个项目，启动多个Tomcat。</p><h3 id="Docker的特点"><a href="#Docker的特点" class="headerlink" title="Docker的特点"></a>Docker的特点</h3><p><strong>1. 秒级的交付和部署<br> 2. 保证环境一致性<br> 3. 动态调度迁移成本低</strong></p><h2 id="关于Docker的几个概念"><a href="#关于Docker的几个概念" class="headerlink" title="关于Docker的几个概念"></a>关于Docker的几个概念</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>Docker的镜像类似于软件的安装包，镜像相当于把整个的系统环境打包起来，只要解压即可使用的这样一种状态，镜像是只读的</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器是基于镜像存在的，它是真正运行项目的一层，容器装载着应用，应用基于容器存在，我们可以将项目部署到应用上，如果将镜像比做一台电脑的话，容器就是镜像中的虚拟机，每个容器都是相互隔离的，互不干扰。</p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>仓库用于存放镜像，像<a href="https://hub.docker.com/">Docker的中央仓库</a>，可以从Docker下载各个环境，软件的镜像。</p><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>systemctl start docker</td><td>启动docker</td></tr><tr><td>systemctl stop docker</td><td>停止docker</td></tr><tr><td>systemctl restart docker</td><td>重启docker</td></tr><tr><td>systemctl status docker</td><td>查看docker状态</td></tr><tr><td>systemctl enable diocker</td><td>查看docker状态</td></tr><tr><td>docker info</td><td>查看docker概要信息</td></tr><tr><td>docker –help</td><td>查看docker帮助文档</td></tr></tbody></table><p>查看状态<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200208182415953.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>docker images</td><td>查看镜像</td></tr><tr><td>docker search 镜像名称</td><td>搜索镜像</td></tr><tr><td>docker pull 镜像名称</td><td>向中央仓库拉取镜像</td></tr><tr><td>docker rmi 镜像ID/镜像名称</td><td>删除镜像</td></tr><tr><td>docker rmi docker images -q</td><td>删除所有镜像</td></tr></tbody></table><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200208183325671.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>docker ps</td><td>查看运行中的容器</td></tr><tr><td>docker ps -a</td><td>查看所有容器</td></tr><tr><td>docker ps -l</td><td>查看最后一次运行的容器</td></tr><tr><td>docker start 容器名称/容器ID</td><td>启动容器</td></tr><tr><td>docker stop 容器名称/容器ID</td><td>停止容器</td></tr><tr><td>docker restart 容器名称/容器ID</td><td>重启容器</td></tr></tbody></table><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200208184256936.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>docker run -it –name=创建的容器名称 /bin /bash</td><td>创建容器，创建后直接进入容器</td></tr><tr><td>docker run  -dt –name=创建的容器名称 /bin /bash</td><td>创建容器</td></tr><tr><td>exit</td><td>退出容器</td></tr></tbody></table><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>删除容器</td><td>docker rm 容器名称/容器ID</td></tr><tr><td>docker rm -f 容器名称</td><td>强制删除容器</td></tr></tbody></table><p>未完待续！！！！</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ入门</title>
      <link href="posts/bae9a0d2.html"/>
      <url>posts/bae9a0d2.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><blockquote><p>消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。y</p></blockquote><p>简单点说：<strong>消息队列是应用程序和应用程序之间的通信方法</strong>。当我们将大项目拆分为许多许多小模块时，我们在这些模块中需要通信时，利用传统的做法就是通过网络调用，这种做法在遇到<strong>高并发</strong>、<strong>网络异常</strong>的情况下，所带来的情况便是响应时间的变长，及可能带来服务的失败。<br>这时我们就要使用上<strong>消息队列</strong>了。我们可将一些<strong>无需即时返回且耗时的操作提取出来</strong>，进行<strong>异步处理</strong>，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而<strong>提高了系统的吞吐量</strong>。<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200113172656348.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><h2 id="消息队列的好处"><a href="#消息队列的好处" class="headerlink" title="消息队列的好处"></a>消息队列的好处</h2><h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><p><strong>消息队列相当于一个中介，生产方通过j消息队列与消费方交互，消息队列将生产者和消费者的依赖关系分离开，实现了解耦合</strong>，消费方无须关心生存方一方的的业务，只需得到相应的通知，然后就会去做对应的事，这样各个模块之间就解耦了。</p><h4 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h4><p><strong>将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理</strong>。当我们去执行一段业务时，我们需要通过网络调用另一段与主线业务无关的业务时，我们可以利用消息队列，将这一段业务交给消息队列去执行，我们只需执行完主线业务然后返回结果即可。<br>举个例子：当我们需要执行【注册业务】时，我们需要执行【发短信业务】,可【发短信业务】所带来的时间，是非常非常久的，这时，我们便可以将【发短信业务】放在消息队列中，从而不会拖慢【注册业务】的时间。</p><h4 id="削峰-x2F-限流"><a href="#削峰-x2F-限流" class="headerlink" title="削峰/限流"></a>削峰/限流</h4><p><strong>让消息不直接到达服务器，先让消息队列保存这些数据，减少同一时刻对服务器的压力</strong>。当同一时刻的请求激增时，我们可以将生产者的请求存储在消息队列中，限制消费方消费消息的速度，这样一来,当出现请求高峰期的时候，不至于将服务器压垮，这种我们就叫<strong>削峰</strong><br>举个例子：【订单系统】当高峰期所达到的高并发足以压垮服务器时，我们可以将下单的请求存到消息队列中，限制服务器的请求量。</p><h2 id="消息队列的实现方式"><a href="#消息队列的实现方式" class="headerlink" title="消息队列的实现方式"></a>消息队列的实现方式</h2><h4 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h4><blockquote><p>Java消息服务（Java Message Service，JMS）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。<br>JMS在特定的API接口层面和实现行为上进行了统一。</p></blockquote><h4 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h4><blockquote><p>高级消息队列协议即Advanced Message Queuing Protocol（AMQP）是面向消息中间件提供的开放的应用层协议。AMQP规范了消息传递方和接收方的行为，以使消息在不同的提供商之间实现互操作性，就像SMTP，HTTP，FTP等协议可以创建交互系统一样。高级消息队列协议关注于各种消息如何以字节流的形式进行传递。因此，使用了符合协议实现的任意应用程序之间可以保持对消息的创建、传递。</p></blockquote><p>简单点说：JMS定义接口来实现，AMQP通过协议实现，AMQP可以通过网络来传递，因此AMQP是跨语言的</p><h2 id="消息队列产品"><a href="#消息队列产品" class="headerlink" title="消息队列产品"></a>消息队列产品</h2><p>ActiveMQ<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200113181914932.jpg" alt=" "><br>ZMQ:<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200113181931240.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "><br>RabbitMQ:<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200113182004236.jpg" alt=" "><br>RockerMQ:<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200113182014703.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "><br>Kafka:</p><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200113182015119.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><blockquote><p>RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。</p></blockquote><p><a href="http://www.rabbitmq.com/">RabbitMQ官方地址</a><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/2020011318234869.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><p>RabbitMQ提供了7种模式：<strong>简单模式，工作队列模式，发布与订阅模式，路由模式，通配符模式，RPC模式，发布者确认模式。</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200113183039103.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "><br>关于RabbitMQ的下载和安装，官网一步到位，这里就不做说明了<br>当我们下载安装完RabbitMQ后（<strong>RabbitMQ的默认账号是guest 密码 guest  默认端口15672</strong>）<br>访问RabbitMQ的网址，看到以下画面即为成功安装。<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200113185803418.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><h3 id="RabbitMQ的几个概念"><a href="#RabbitMQ的几个概念" class="headerlink" title="RabbitMQ的几个概念"></a>RabbitMQ的几个概念</h3><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200114161354126.jpg" alt=" "></p><h4 id="Connection-连接-："><a href="#Connection-连接-：" class="headerlink" title="Connection(连接)："></a>Connection(连接)：</h4><p>基于AMQP协议的网络连接，比如TCP/IP套接字连接。当使用RabbitMQ时便会创建连接，开启信道，连接到RabbitMQ，当消息发送完毕便会关闭信道、关闭连接。</p><h4 id="Channel（信道"><a href="#Channel（信道" class="headerlink" title="Channel（信道):"></a>Channel（信道):</h4><p>RabbitMQ之间使用 TCP 连接，加入每次发布消息都要连接TCP，这不仅会造成连接资源严重浪费，RabbitMQ 引入了信道的概念，所有需要发布消息的线程都包装成一条信道在 TCP 中传输，理论上 一条 TCP 连接支持无限多个信道。<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200114162613865.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><h4 id="Exchanges-交换机-："><a href="#Exchanges-交换机-：" class="headerlink" title="Exchanges(交换机)："></a>Exchanges(交换机)：</h4><p>在Rabbit的几种模式中，从发布订阅模式开始便引入了交换机这一概念，利用交换机，将消息存放在交换机中，<strong>由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收消息</strong>，做到了一条消息多个共享。</p><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200114164652843.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><h4 id="Queues（队列"><a href="#Queues（队列" class="headerlink" title="Queues（队列):"></a>Queues（队列):</h4><p>用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。<strong>一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200114164645720.jpg" alt="  "></p><h4 id="virtual-host（域）"><a href="#virtual-host（域）" class="headerlink" title="virtual_host（域）"></a>virtual_host（域）</h4><p>域是rabbitmq分配权限的最小细粒度。比如我们可以为一个用户分配一个可以访问哪个域。所以可以多个user共同使用一个virtual host，不同的命名空间之间的资源是不能访问的。<strong>域是一个权限的标记，标记用户访问的权限</strong></p><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/202001211754117.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p><strong>依赖</strong></p><h5 id="消费者和生产者依赖相同"><a href="#消费者和生产者依赖相同" class="headerlink" title="消费者和生产者依赖相同"></a>消费者和生产者依赖相同</h5><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121174430209.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><p><strong>配置文件</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/2020012117444826.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><p>在RabbitMQ的官方文档中，我们可以看到我们需要发送方和接收方。为了方便，这里统一使用SpringBoot整合RabbitMQ，SpringBoot为我们解决了繁琐的创建过程，其他方式差不多一样，有兴趣可以到官方文档中查看，这里就不一一演示。<strong>这里讲几个典型的，其他可参考官方文档</strong>。</p><blockquote><p>我们将调用消息发布者(发送方)Send和消息使用者(接收方)Recv。发布者将连接到RabbitMQ，发送一条消息，然后退出。在发送。java，我们需要导入一些类</p></blockquote><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121151212815.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><h3 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h3><p><strong>一个生产者、一个消费者，依靠队列交换消息，队列相当于一个中转站</strong></p><ul><li>P：生产者： 发送消息到队列</li><li>C：消费者： 消费队列中的消息</li><li>Queue：消息队列，接收消息、缓存消息。<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121175720387.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></li></ul><p><strong>生产者</strong><br><strong>模拟一个消息的发送</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/2020012118424921.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><p><strong>配置类</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121182225477.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><p><strong>启动看效果</strong></p><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121173109580.jpg" alt=" "><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121173127867.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "><br>我们可以看到在RabbitMQ的页面上生成了<strong>信道和队列</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121173312403.jpg" alt=" "><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121173341950.jpg" alt=" "><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121173416197.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "><br><strong>消费者</strong></p><p><strong>监听队列</strong></p><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121182118896.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70"><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121173908608.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "><br>到这里简单模式的的入门就到处为止了。<br><strong>简单模式是里面典型的一种模式，指不加入交换机，单点对单点的这种形式，这种模式的缺点就是一个消息就只能由一个消费，，不能做到多个消费者共用同一个消息，这种模式还有工作队列模式，工作队列只不过在简单模式的基础上有多个消费者而已，因此就不做演示。</strong></p><h3 id="发布与订阅模式"><a href="#发布与订阅模式" class="headerlink" title="发布与订阅模式"></a>发布与订阅模式</h3><p> P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）<br> C：消费者， 消费队列中的消息。<br> Queue：消息队列，接收消息、缓存消息。<br>X：- <strong><font color="red">Exchange</font></strong>：交换机，。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如把消息递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型：</p><ul><li><strong><font color="red">Fanout</font></strong>：广播，将消息交给所有绑定到交换机的队列</li><li><strong><font color="red">Direct</font></strong>：定向，把消息交给符合指定routing key 的队列</li><li><strong><font color="red">Topic</font></strong>：通配符，把消息交给符合的队列，模糊匹配。<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121175903391.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "><br><strong>绑定交换机</strong></li></ul><p>第二个参数为路由模式的参数，如无，为空即可<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121192056761.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><p><strong>配置类</strong></p><p>·配置交换机<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121190453881.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><p><strong>消费者（编写两个消费者）</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121193915334.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><p><strong>绑定队列和交换机</strong></p><p>启动后在RabbitMQ中生成了新的交换机和新的信道<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121193857797.jpg" alt=" "><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121190934512.jpg" alt="  "></p><p>启动测试<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121192244812.jpg" alt="  "></p><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>路由模式即多了一个路由的key，只有拥有指定路由key的消费者才可以访问</p><p><strong>生产者</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121202232282.jpg" alt=" "></p><p><strong>配置类</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121202249453.jpg" alt=" "></p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>在一个消费者上绑定不同的路由Key<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/202001211944000.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121202308135.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "><br>启动测试（收到不同的消息）<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121202415778.jpg" alt=" "><br>通配符模式，关于通配符模式跟路由模式差不多，只需在绑定的路由key上指定模糊匹配即可，让队列在绑定 Routing key  的时候使用。<br>匹配规则如下</p><pre class="line-numbers language-none"><code class="language-none"># 匹配一个或多个词* 匹配不多不少恰好1个词<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>关于其他的一些配置，下次再聊<br>个人博客  <a href="https://juhaozero.github.io/">juhaozero的博客</a></p><p><strong>新年快乐，明年见</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121203917897.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 入门</title>
      <link href="posts/4abc8450.html"/>
      <url>posts/4abc8450.html</url>
      
        <content type="html"><![CDATA[<h2 id="传统DB的缺点"><a href="#传统DB的缺点" class="headerlink" title="传统DB的缺点"></a>传统DB的缺点</h2><p>像Mysql、和Oracle 这种关系型数据库，虽然有着数据稳定和服务稳定、数据一致性的特点，但也存在一个致命的缺陷:</p><h4 id="高并发下DB不稳定"><a href="#高并发下DB不稳定" class="headerlink" title="高并发下DB不稳定"></a>高并发下DB不稳定</h4><p>在高并发的情况下，DB的不稳定性，在大量用户访问时DB出奇的慢，因为对磁盘操作需要使用IO流，一个字节一个字节存取操作。要将所有数据读取到内存中后才可以操作。所以在高并发下DB的<strong>高可用</strong>便成了问题。这时NoSQL便应运而生。</p><h3 id="什么是NOSQl"><a href="#什么是NOSQl" class="headerlink" title="什么是NOSQl"></a>什么是NOSQl</h3><blockquote><p>NoSQL是对不同于传统的关系数据库的数据库管理系统的统称。即非关系型数据库<br>NOSQL：因为是内存操作数据，非常快,解决了三高问题（高并发、高海量、高可用）</p></blockquote><p><strong>非关系型数据库与非关系型数据库的区别</strong></p><table><thead><tr><th>关系型数据库</th><th>非关系型数据库</th></tr></thead><tbody><tr><td>以文件方式保存</td><td>存储在内存中，服务器关闭数据可能会丢失</td></tr><tr><td>数据可以永久保存</td><td>不能持久化保存，可能导致数据丢失</td></tr><tr><td>查询速度慢</td><td>存取速度快</td></tr></tbody></table><p>常见的NOSQL数据库<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200107160826641.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200107164533556.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>简单翻译下</p><blockquote><p>Redis是一个开源(BSD许可)的内存数据结构存储，用作数据库、缓存和消息代理。它支持诸如字符串、散列、列表、集、带范围查询的排序集、位图、hyperloglogs、带半径查询和流的地理空间索引等数据结构。Redis具有内置的复制、Lua脚本、LRU清除、事务和不同级别的磁盘持久性，并通过Redis Sentinel和带有Redis集群的自动分区提供高可用性</p></blockquote><p>redis的安装可以到官网下载，这里就不演示了。</p><h4 id="Redis是一种高级的key-value存储系统，其中value支持五种数据类型"><a href="#Redis是一种高级的key-value存储系统，其中value支持五种数据类型" class="headerlink" title="Redis是一种高级的key:value存储系统，其中value支持五种数据类型"></a>Redis是一种高级的<strong>key:value</strong>存储系统，其中value支持五种数据类型</h4><ul><li><p><strong>字符串（strings）</strong></p></li><li><p>字符串无序集合（Set）</p></li><li><p>有序字符串集合（zset）</p></li><li><p>字符串列表（List）</p></li><li><p>-哈希类型（hash）</p></li></ul><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>字符串类型是 Redis 中最为基础的数据存储类型，<strong>它在 Redis 中以二进制保存，没有编码和解码的过程</strong>，String字符串类型的Value数据长度512M</p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>set key 值</td><td>添加字符串类型键和值</td></tr><tr><td>get  key 值</td><td>取出指定类型的值，没有返回null</td></tr><tr><td>del key</td><td>删除指定的key 返回删除的个数 没有返回0</td></tr><tr><td><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200107165300155.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></td><td></td></tr></tbody></table><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>我们可以将 Set 类型看作为没有排序的字符集合</p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>sadd  key  值1、值2</td><td>向集合中添加一个或多个元素</td></tr><tr><td>smembers key</td><td>查询指定集合所有的元素</td></tr><tr><td>sismember key 值</td><td>查询某个值是否存在 存在返回1、反则</td></tr><tr><td>srem key 值1、值2</td><td>删除指定元素</td></tr></tbody></table><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200107170803104.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><h3 id="Zset类型"><a href="#Zset类型" class="headerlink" title="Zset类型"></a>Zset类型</h3><p>集合一样也是string类型元素的集合,且不允许重复的成员。<br><strong>不同的是每个元素都会关联一个分数。redis正是通过分数来为集合中的成员进行从小到大的排序</strong>。有序集合的成员是唯一的,但分数(score)却可以重复，每个集合可存储40多亿个成员</p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>zadd key   分数  值</td><td>向集合 添加一个或多个元素</td></tr><tr><td>zrang key 开始 结束</td><td>返回集合中指定区间内的元素</td></tr><tr><td>zrem key 值</td><td>删除集合的 一个元素或多个元素</td></tr><tr><td>zcard key</td><td>获取集合中的元素数</td></tr><tr><td>zrank key 值</td><td>返回集合中指定成员的索引</td></tr></tbody></table><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200107174332626.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><h2 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h2><p> List 类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其左部(left)和右部(right)添加新的元素。</p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>lpush key 元素1 元素2</td><td>往链表左边添加元素 键不存在则 创建新链表</td></tr><tr><td>rpush key 元素1 元素2</td><td>往链表右边添加元素 键不存在则 创建新链表</td></tr><tr><td>lrange key 开始 结束</td><td>取出指定范围的元素列表 左边数第一个为0 右边数第一个为-1</td></tr><tr><td>lpop key</td><td>从左边删除一个元素</td></tr><tr><td>rpop key</td><td>从右边删除一个元素</td></tr><tr><td>llen key</td><td>得到指定链表的长度</td></tr><tr><td><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109160119551.jpg" alt="  "></td><td></td></tr><tr><td><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109160135742.jpg" alt="  "></td><td></td></tr></tbody></table><h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p>Redis 中的 Hash 类型可以看成具 String 的键和 String 的值 Map 容器，每一个 Hash 可以存储 40（42 亿 9千多个）亿个键值对。</p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>hset key  MapKey 值</td><td>向指定的key中添加 hasnMap类型</td></tr><tr><td>hget key  MapKey</td><td>获取指定key中的指定HashMap</td></tr><tr><td>hmset key MapKey1 值  MapKey2 值</td><td>向一个键中设置多个Map和值</td></tr><tr><td>hmget key MapKey1 MapKey2</td><td>获取一个键中的多个Map</td></tr><tr><td>hdel key MapKey1 MapKey1</td><td>删除一个键中的多个Map</td></tr><tr><td>hgetall  key</td><td>得到一个键中的所有Map</td></tr><tr><td><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109163249198.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></td><td></td></tr><tr><td>批量插入Map</td><td></td></tr><tr><td><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109163307979.jpg" alt="  "></td><td></td></tr><tr><td>删除Map</td><td></td></tr><tr><td><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/2020010916333456.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></td><td></td></tr></tbody></table><h2 id="其他操作命令"><a href="#其他操作命令" class="headerlink" title="其他操作命令"></a>其他操作命令</h2><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>keys  匹配字符</td><td>查询数据库的键 （ *   为匹配全部字符）</td></tr><tr><td>del key1  key2</td><td>删除任意键</td></tr><tr><td>exists key</td><td>判断指定键是否存在</td></tr><tr><td>type key</td><td>判断该key 属于哪种类型</td></tr><tr><td>select 数据库编号</td><td>选择指定的数据库</td></tr><tr><td>move key 数据库编号</td><td>将某个键移动到另一个数据库</td></tr><tr><td>Expire key  秒</td><td>设置过期时间</td></tr><tr><td>TTL key</td><td>返回剩余生存时间</td></tr><tr><td><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/2020010917015779.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="   "></td><td></td></tr></tbody></table><p>Redis数据库，Redis默认有16个数据库，我们可以通过Redis的一个图形化工具查看<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109170353435.jpg" alt=" "><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109171834997.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/2020010917220188.jpg" alt="  "><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109172228496.jpg" alt="  "></p><h4 id="设置过期时间（过期时为-2）"><a href="#设置过期时间（过期时为-2）" class="headerlink" title="设置过期时间（过期时为-2）"></a>设置过期时间（过期时为-2）</h4><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109174955819.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="   "></p><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis的最大特色就是<strong>持久化机制</strong>，当发生服务器宕机等不可预料因素时，Redis会将符合条件的数据进行持久化，在重启时恢复数据。RDB 和 AOF 是 Redis 内部的两种数据持久化策略，这是两种不同的持久化策略，<strong>一种是基于内存快照，一种是基于操作日志</strong></p><h3 id="RDB持久化策略（基于内存快照）"><a href="#RDB持久化策略（基于内存快照）" class="headerlink" title="RDB持久化策略（基于内存快照）"></a>RDB持久化策略（基于内存快照）</h3><blockquote><p>RDB(Redis DataBase)持久化策略就是在符合一定条件下将内存所有数据持久化到磁盘中dump.rdb文件中。RDB策略是redis默认持久化策略。也叫快照策略。</p></blockquote><p>什么是快照策略，RDB持久化是指在某一段时间内将该内存下所有的数据存储为文件，当服务器丢失时，自动恢复到最新的一份RDB文件，简单点说就是相当于每隔一段时间就将Redis的文件<br>做一次备份，<strong>当然要满足一定的要求</strong> RDB持久化是Redis默认的持久化机制</p><p>在安装完Redis的目录下有个config文件<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109192335792.jpg" alt="  "><br>在该文件下我们可以找到这样一段话<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109192413876.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "><br>简单翻译一下就是</p><blockquote><p>将DB保存到磁盘上:<br>在下面的例子中行为将保存DB<br>900秒后(15分钟)如果至少1键改变了<br>300秒(5分钟)如果至少10键改变<br>60秒后如果至少10000键改变</p><p>也就是说：<br><strong>当数据在15分钟内改变了一个key，就会执行持久化机制<br>如果数据在5分钟内有10个key改变，就会执行持久化机制<br>如果数据在1分钟内有10000key改变，就会执行持久化机制</strong></p></blockquote><p>而我们持久化完的数据在哪里显示呢？<br>在该文件下面也有进行说明<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109193309603.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "><br>简单翻译下</p><blockquote><p>要将数据库转储到何处的文件名</p><p>于是我们就可以在Redis的安装目录下找到这个文件<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109193539993.jpg" alt="  "></p></blockquote><h3 id="关于RDB持久化机制"><a href="#关于RDB持久化机制" class="headerlink" title="关于RDB持久化机制"></a>关于RDB持久化机制</h3><p>RDB的持久化机制，我们可以在配置文件中修改持久化时间，但一般不建议修改，因为在Redis达到一定数据量时，频繁的进行RDB的持久化机制便是一个非常浪费性能的事。RDB的持久机制<br>不高，便意味可能RDB持久化会导致丢失一定的数据。以快的持久化时间来说，相当于我们还是有60秒的空档期。而这可以靠另一个持久化机制来解决。</p><h3 id="AOF持久化策略（基于操作日志）"><a href="#AOF持久化策略（基于操作日志）" class="headerlink" title="AOF持久化策略（基于操作日志）"></a>AOF持久化策略（基于操作日志）</h3><blockquote><p> AOF(append only file)策略，是基于操作日志实现的<br> 它的特点持久化的频率非常高了，默认每秒持久化1次。每一秒内将最新的<font color="red"><strong>写入与删除</strong></font>的命令进行持久化。</p></blockquote><p>AOF的持久化机制和RDB的持久化机制完全不同，AOF是基于日志文件操作的，简单点说就是RDB会将数据进行备份，而<font color="red"><strong>AOF备份的是操作</strong></font> , 就是说，AOF将你所有的<strong>写入和删除</strong>操作进行备份，当服务器宕机时，可以通过备份的操作还原数据。</p><p>在配置文件中有这么一小段<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109200757357.jpg"><br>简单翻译下</p><blockquote><p>可以同时启用AOF和RDB持久性，没有问题。如果在启动时启用了AOF，那么Redis将加载AOF，即具有更好持久性保证的文件</p></blockquote><h6 id="开启AOF机制"><a href="#开启AOF机制" class="headerlink" title="开启AOF机制"></a>开启AOF机制</h6><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109200859573.jpg" alt="  "></p><h5 id="AOF持久化选择"><a href="#AOF持久化选择" class="headerlink" title="AOF持久化选择"></a>AOF持久化选择</h5><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109201312398.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "><br>简单翻译下</p><blockquote><p>默认设置是“每隔一秒”，因为这通常是正确的折衷<br>速度和数据安全。这取决于你是否能慢下来<br>“no”将允许操作系统在何时刷新输出缓冲区<br>为了更好的表现(但是如果你能接受一些数据丢失更多考虑的是快照的默认RDB持久性模式)，或者相反，使用“always”，虽然很慢，但是更安全。</p></blockquote><p>这里指的是AOF提供持久化的频率<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109201559103.jpg" alt="在这里插入图片描述"><br>always：指每次修改都进行持久化操作，效率是最低的，但也是最安全的。<br>everysec：指每秒持久化一次，默认使用<br>no：指的是不进行持久化，效率最高</p><h5 id="AOF的重写机制"><a href="#AOF的重写机制" class="headerlink" title="AOF的重写机制"></a>AOF的重写机制</h5><p>当AOF开启时每秒的操作都会进行持久化，这样会导致日志文件的过大<br>于是AOF就有了重写机制，同样在配置文件下<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109203646265.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><p>简单翻译下</p><blockquote><p>这个基本大小与当前大小进行比较。如果当前大小大于指定的百分比，将触发重写。您需要为要重写的AOF文件指定一个最小的大小</p></blockquote><p><strong>默认当日志文件大小超过内存数据100%时触发重写<br>当日志文件达到64M时也触发重写</strong></p><h3 id="关于AOF持久化机制"><a href="#关于AOF持久化机制" class="headerlink" title="关于AOF持久化机制"></a>关于AOF持久化机制</h3><p> AOF策略的优点是显而易见的， 每秒持久化，具有更高的数据安全，如果服务器崩溃只会丢1秒内的数据，但缺点也是一样明显：由于持久化频率高，Redis的性能会变低。</p><p>值得注意的是AOF和RDB同时开启，默认使用AOF恢复数据，<br>因为AOF是秒级以内的容错。</p><h4 id="关于两者的选用"><a href="#关于两者的选用" class="headerlink" title="关于两者的选用"></a>关于两者的选用</h4><h5 id="官方建议"><a href="#官方建议" class="headerlink" title="官方建议"></a>官方建议</h5><blockquote><p>通常，如果你要想提供很高的数据保障性，那么建议你同时使用两种持久化方式。<br>如果你可以接受灾难带来的几分钟的数据丢失，那么你可以仅使用RDB。很多用户仅使用了AOF，但是我们建议，既然RDB可以时不时的给数据做个完整的快照，并且提供更快的重启，所以最好还是也使用RDB。<br>因此，我们希望可以在未来（长远计划）统一AOF和RDB成一种持久化模式。</p></blockquote><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>关于Redis就讲到这里了<br>有空再更！！！！<br>个人博客：<a href="https://juhaozero.github.io/">juhaozero的博客</a><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/2020010920475983.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="    "></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
