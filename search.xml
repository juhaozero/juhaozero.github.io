<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nginx-命令.md</title>
      <link href="posts/757444c7.html"/>
      <url>posts/757444c7.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git 常用命令</title>
      <link href="posts/5fddf106.html"/>
      <url>posts/5fddf106.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>写在前面, 整理了一些网上的git命令,不定时补充</p></blockquote><h1 id="Git-命令"><a href="#Git-命令" class="headerlink" title="Git 命令"></a>Git 命令</h1><h2 id="1-生成-SSH-Key"><a href="#1-生成-SSH-Key" class="headerlink" title="1. 生成 SSH Key"></a>1. 生成 SSH Key</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">ssh-keygen -t rsa -C <span class="token string">"youremail@xxx.com"</span><span class="token comment"># 输入之后直接两次回车即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-查看-git-用户名和邮箱地址"><a href="#2-查看-git-用户名和邮箱地址" class="headerlink" title="2.查看 git 用户名和邮箱地址"></a>2.查看 git 用户名和邮箱地址</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 查看用户名</span>git config user.name<span class="token comment"># 查看邮箱地址</span>git config user.email<span class="token comment"># 查看配置信息</span>git config --list<span class="token comment"># 当前用户全局</span>git config --global<span class="token comment"># 当前系统全局</span>git config --system<span class="token comment"># 修改用户名</span>git config --global user.name <span class="token string">"username"</span><span class="token comment"># 修改邮箱地址</span>git config --global user.email <span class="token string">"email"</span><span class="token comment"># 重新输入账号密码</span>git config --system --unset credential.helper<span class="token comment"># 查看 git 配置信息</span>git config --list 或者 git config -l<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-初始化一个-git-仓库"><a href="#3-初始化一个-git-仓库" class="headerlink" title="3.初始化一个 git 仓库"></a>3.初始化一个 git 仓库</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-添加文件到-git-仓库"><a href="#4-添加文件到-git-仓库" class="headerlink" title="4.添加文件到 git 仓库"></a>4.添加文件到 git 仓库</h2><ol><li>添加文件到缓存区</li></ol><pre class="line-numbers language-git" data-language="git"><code class="language-git">git add &lt;filename&gt;<span class="token comment"># 比如添加 file.txt 文件： git add file.txt</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>2.将缓存区文件提交到本地仓库</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">git commit -m <span class="token string">"add_file_message"</span><span class="token comment"># 比如提交 file.txt 文件：git commit -m "add file.txt"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="5-查看修改内容对比，提交到缓存区或者已经提交到本地仓库，使用-git-diff-会没有内容显示，也就是说只要修改了，在提交到缓存区之前使用-git-diff-才有用-（查看工作区的改变）"><a href="#5-查看修改内容对比，提交到缓存区或者已经提交到本地仓库，使用-git-diff-会没有内容显示，也就是说只要修改了，在提交到缓存区之前使用-git-diff-才有用-（查看工作区的改变）" class="headerlink" title="5.查看修改内容对比，提交到缓存区或者已经提交到本地仓库，使用 git diff 会没有内容显示，也就是说只要修改了，在提交到缓存区之前使用 git diff 才有用 （查看工作区的改变）"></a>5.查看修改内容对比，提交到缓存区或者已经提交到本地仓库，使用 git diff 会没有内容显示，也就是说只要修改了，在提交到缓存区之前使用 git diff 才有用 （查看工作区的改变）</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git diff<span class="token comment"># 还可以查看具体哪个文件做了什么修改</span><span class="token comment"># 比如查看 readme.txt 做了什么修改</span>git diff HEAD -- readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-查看当前仓库状态，任何时候都可以使用"><a href="#6-查看当前仓库状态，任何时候都可以使用" class="headerlink" title="6.查看当前仓库状态，任何时候都可以使用"></a>6.查看当前仓库状态，任何时候都可以使用</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="7-查看提交日志"><a href="#7-查看提交日志" class="headerlink" title="7.查看提交日志"></a>7.查看提交日志</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 查看全部 </span>git log<span class="token comment"># 查看最后一次提交</span>git show<span class="token comment"># 查看倒数5条</span>git log -5<span class="token comment"># 简化日志显示方式，并含有提交版本号</span>git log --pretty=oneline<span class="token comment"># 比如：</span><span class="token comment"># $ git log --pretty=oneline</span><span class="token comment"># 44c9beb4c58543b89181829755be2c5e9781ba28 (HEAD -&gt; master) append GPL</span><span class="token comment"># 03112bdf101655c30df9b61e4bd325b2cbe3c090 add distributed</span><span class="token comment"># 8a1386bd0fe677bca99d5a4ef26e87772a3eca71 wrote a readme file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-回退版本"><a href="#8-回退版本" class="headerlink" title="8.回退版本"></a>8.回退版本</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 回退当前版本的上一个版本</span>git reset --hard HEAD^<span class="token comment"># 回退当前版本的上三个版本</span>git reset --hard HEAD^^^<span class="token comment"># 回退当前版本的上 100 个版本</span>git reset --hard HEAD~100<span class="token comment"># 回退指定版本，并将 「回退」动作作为一个版本提交</span>git revert &lt;commit id&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="9-回退指定版本"><a href="#9-回退指定版本" class="headerlink" title="9. 回退指定版本"></a>9. 回退指定版本</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git reset --hard 版本号前几位<span class="token comment"># 比如回退到 以上查看日志中的 add distributed 这个提交版本</span>git reset --hard 44c9beb4c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="10-查看提交版本号-commit-id"><a href="#10-查看提交版本号-commit-id" class="headerlink" title="10. 查看提交版本号 commit id"></a>10. 查看提交版本号 commit id</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 要重返未来，用 `git reflog` 查看命令历史，以便确定要回到未来的哪个版本。</span>git reflog<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="11-撤销修改"><a href="#11-撤销修改" class="headerlink" title="11.撤销修改"></a>11.撤销修改</h2><ol><li><strong>修改只在工作区，还没有添加到缓存区 （还没有 git add）</strong></li></ol><pre class="line-numbers language-git" data-language="git"><code class="language-git">git checkout -- filename<span class="token comment"># 比如 readme.txt 文件只是在工作区修改了，想回退到修改之前的提交的版本</span>git checkout -- readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>修改从工作区已经提交到了缓存区 （已经 git add）</strong></li></ol><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 将缓存区的修改回退到工作区</span>git reset HEAD filename<span class="token comment"># 比如 readme.txt 文件的修改已经提交到缓存区了，但是想撤销修改分为两步</span><span class="token comment"># 01.将缓存区的修改回退到工作区</span>git reset HEAD readme.txt<span class="token comment"># 02.将在工作区的修改回退到和上一个版本一样</span>git checkout -- readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>修改已经从缓存区提交到了本地仓库 （已经 git commit）</strong></li></ol><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 回退当前版本的上一个版本</span>git reset --hard HEAD^<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="4"><li><strong>将在暂存区的更改文件进行强制撤销。（想让之前已经提交到缓存区的文件覆盖工作区的文件）</strong></li></ol><pre class="line-numbers language-git" data-language="git"><code class="language-git">git checkout -f<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>5.** 命令 git clean 作用是清理项目，-f 是强制清理文件的设置，-d 选项命令连文件夹一并清除**</p><pre class="line-numbers language-git" data-language="git"><code class="language-git">git clean -f -d<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li><strong>假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它：</strong></li></ol><pre class="line-numbers language-git" data-language="git"><code class="language-git">git fetch origin git reset --hard origin/master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="12-删除文件"><a href="#12-删除文件" class="headerlink" title="12.删除文件"></a>12.删除文件</h2><p><strong>1. 确实要删除该文件</strong></p><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 比如以 test.txt 为例子</span><span class="token comment"># 01 本地手动删除 test.txt 文件</span>rm test.txt 或者 rm -rf test.txt<span class="token comment"># 02 添加被删除的状态缓存区</span>git rm test.txt 或者 git add test.txt<span class="token comment"># 03 提交状态到本地仓库</span>git commit -m <span class="token string">"remove test.txt"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2. 工作区误删了文件</strong></p><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 01 工作区误删了 test.txt 文件</span>rm test.txt<span class="token comment"># 02 找回被误删的文件（撤销修改）</span>git checkout -- test.txt<span class="token comment"># 用版本库中的版本替换掉工作区的版本</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="13-创建分支并切换到该分支"><a href="#13-创建分支并切换到该分支" class="headerlink" title="13.创建分支并切换到该分支"></a>13.创建分支并切换到该分支</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git checkout -b juhaozero  或者 git switch -c juhaozero<span class="token comment"># 创建 juhaozero 分支并切换到 juhaozero 分支</span><span class="token comment"># 等同于以下两个命令</span><span class="token comment"># 创建 juhaozero 分支</span>git branch juhaozero<span class="token comment"># 切换到 juhaozero 分支</span>git checkout juhaozero  或者 git switch juhaozero<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="14-合并指定分支到当前分支"><a href="#14-合并指定分支到当前分支" class="headerlink" title="14.合并指定分支到当前分支"></a>14.合并指定分支到当前分支</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 比如当前位于 master 分支，欲将 juhaozero 分支合并到 master 分支</span>git merge juhaozero<span class="token comment"># 如果有冲突，解决步骤如下：</span><span class="token comment"># 01 先查看冲突文件</span>git status<span class="token comment"># 02 手动解决冲突文件</span><span class="token comment"># 03 再次合并分支</span>git merge juhaozero<span class="token comment"># 04 添加修改到缓存区</span>git add .<span class="token comment"># 05 提交到本地仓库</span>git commit -m <span class="token string">"merge fixed"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="15-查看分支的合并情况"><a href="#15-查看分支的合并情况" class="headerlink" title="15.查看分支的合并情况"></a>15.查看分支的合并情况</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git log --graph --pretty=oneline --abbrev-commit或者直接使用 git log --graph 命令可以看到分支合并图。<span class="token comment"># 设置别名查看所有的提交记录</span>git config --global alias.lg <span class="token string">"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="16-删除分支"><a href="#16-删除分支" class="headerlink" title="16.删除分支"></a>16.删除分支</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 合并代码之后删除分支 </span>git branch -d 分支名<span class="token comment"># 没有合并代码删除分支 </span>git branch -D 分支名<span class="token comment"># 删除远程分支（本地分支需要再次手动删除）</span>git push origin -d 分支名<span class="token comment"># 比如删除 juhaozero 分支</span>git branch -d juhaozero<span class="token comment"># 删除远程 juhaozero 分支</span>git push origin -d juhaozero<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="17-查看分支"><a href="#17-查看分支" class="headerlink" title="17.查看分支"></a>17.查看分支</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 只查看远程分支</span>git branch -r<span class="token comment"># 只查看本地分支</span>git branch<span class="token comment"># 查看所有远程分支和本地分支</span>git branch -a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="18-拉取远程分支并创建同名本地分支"><a href="#18-拉取远程分支并创建同名本地分支" class="headerlink" title="18.拉取远程分支并创建同名本地分支"></a>18.拉取远程分支并创建同名本地分支</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git"><span class="token comment"># 方法一（此方法建立的本地分支和远程分支会有映射关系）</span>git checkout -b [本地分支名] origin/[远程分支名]举例：git checkout -b juhaozero origin/juhaozero<span class="token comment"># 方法二（此方法建立的本地分支和远程分支没有映射关系）</span>git fetch origin [远程分支名]:[本地分支名]举例：git fetch origin juhaozero:juhaozero<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="19-查看本地分支和远程分支的映射关系（远程有的分支而本地没有的分支不会出现）"><a href="#19-查看本地分支和远程分支的映射关系（远程有的分支而本地没有的分支不会出现）" class="headerlink" title="19.查看本地分支和远程分支的映射关系（远程有的分支而本地没有的分支不会出现）"></a>19.查看本地分支和远程分支的映射关系（远程有的分支而本地没有的分支不会出现）</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git branch -vv<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="20-手动建立本地分支和远程分支的映射关系"><a href="#20-手动建立本地分支和远程分支的映射关系" class="headerlink" title="20.手动建立本地分支和远程分支的映射关系"></a>20.手动建立本地分支和远程分支的映射关系</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git branch -u origin/[分支名]或者git branch --set-upstream-to origin/[分支名]或者git branch --set-upstream-to=origin/[远程分支名] [本地分支名]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="21-推送分支"><a href="#21-推送分支" class="headerlink" title="21.推送分支"></a>21.推送分支</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git push -u origin &lt;branch name&gt; <span class="token comment"># 第一次推送的时候添加 -u 参数，给本地分支和远程分支创建连接关系，当第二次再次推送时，则不需要添加 -u 参数</span><span class="token comment"># 比如：推送 dev 分支</span>git push origin dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="22-查看远程库的信息"><a href="#22-查看远程库的信息" class="headerlink" title="22.查看远程库的信息"></a>22.查看远程库的信息</h2><pre class="line-numbers language-git" data-language="git"><code class="language-git">git remote<span class="token comment"># 查看远程库更加详细的信息</span><span class="token comment"># 这里可以看到抓取和推送的 origin 的地址</span>git remote -v （小写的v）<span class="token comment"># 删除远程库连接</span>git remote rm &lt;origin name&gt;<span class="token comment"># eg：删除远程 origin 连接</span>git remote rm origin<span class="token comment"># 添加远程库连接</span>git remote add &lt;origin name&gt; &lt;ssh or http&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="23-三种状态命令比较"><a href="#23-三种状态命令比较" class="headerlink" title="23.三种状态命令比较"></a>23.三种状态命令比较</h2><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>git add .</td><td>提交所有修改的和新建的数据暂存区 (提交当前文件夹下所有修改)</td></tr><tr><td>git add -u</td><td>提交所有被删除和修改的文件到数据暂存区（等同于git add -update）</td></tr><tr><td>git add -A</td><td>提交所有被删除、被替换、被修改和新增的文件到数据暂存区（等同于git add –all）</td></tr></tbody></table><h2 id="附一张常用命令表"><a href="#附一张常用命令表" class="headerlink" title="附一张常用命令表"></a>附一张常用命令表</h2><p><img src="/medias/loading.gif" data-original="/posts/5fddf106/011500266295799.jpg"></p><h3 id="暂时先到这里，有空再找其他来补充"><a href="#暂时先到这里，有空再找其他来补充" class="headerlink" title="暂时先到这里，有空再找其他来补充"></a>暂时先到这里，有空再找其他来补充</h3>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 常见命令</title>
      <link href="posts/59b529b7.html"/>
      <url>posts/59b529b7.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker-常见命令"><a href="#docker-常见命令" class="headerlink" title="docker 常见命令"></a>docker 常见命令</h1><ul><li>查看版本</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看详细版本</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看 docker 基本信息</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> info<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><hr><h2 id="镜像相关的命令"><a href="#镜像相关的命令" class="headerlink" title="镜像相关的命令"></a>镜像相关的命令</h2><p>镜像仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com</a></p><ul><li>查看本地已经安装的镜像</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>搜索指定镜像</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> search <span class="token operator">&lt;</span>image-name<span class="token operator">&gt;</span><span class="token comment"># 比如搜索 centos 镜像</span><span class="token function">docker</span> search centos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>拉取镜像</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull <span class="token operator">&lt;</span>image-name<span class="token operator">&gt;</span><span class="token comment"># 比如拉取 centos 镜像（将会拉取最新版本的镜像，即 latest 版本）</span><span class="token function">docker</span> pull centos<span class="token comment"># 拉取指定版本的镜像</span><span class="token function">docker</span> pull ubuntu:16.04<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>删除镜像</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> rmi <span class="token operator">&lt;</span>image-name<span class="token operator">&gt;</span><span class="token comment"># 比如删除 centos 镜像</span><span class="token function">docker</span> rmi centos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>删除所有的镜像</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> rmi <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> images <span class="token parameter variable">-q</span><span class="token variable">)</span></span><span class="token comment"># 查看所有镜像的镜像 id</span><span class="token function">docker</span> images <span class="token parameter variable">-q</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>更新镜像</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 更新镜像前，需要使用镜像创建一个容器</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> ubuntu:15.10 <span class="token function">bash</span><span class="token comment"># 在运行的容器内部使用 apt-get update 更新</span><span class="token comment"># 更新完毕之后，输入 exit 命令退出容器</span><span class="token comment"># 使用 docker commit 来提交容器副本</span><span class="token function">docker</span> commit <span class="token parameter variable">-m</span><span class="token operator">=</span><span class="token string">"has update"</span> <span class="token parameter variable">-a</span><span class="token operator">=</span><span class="token string">"juhaozero"</span> e218edb10161 juhaozero/ubuntu:v2<span class="token comment"># -m 表示提交的描述信息</span><span class="token comment"># -a 表示提交的镜像作者</span><span class="token comment"># e218edb10161 表示容器的 id</span><span class="token comment"># juhaozero/ubuntu:v2 表示指定要创建的目标镜像名</span><span class="token comment"># 查看新的镜像</span><span class="token function">docker</span> images<span class="token comment"># 使用新镜像 juhaozero/ubuntu:v2 来启动一个容器</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> juhaozero/ubuntu:v2 <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>构建镜像</li></ul><ol><li>vim  ~/glory/codes/book/demo/Dockerfile 填充以下内容，构建一个 centos 8 系统</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 指定使用哪个镜像源</span>FROM centos:8<span class="token comment"># 如果写了 3 次 RUN 那么将会在 docker 上新建 3 层，会导致镜像膨胀过大，下面这种方式只会创建 1 层镜像</span>RUN /bin/echo <span class="token string">'root:123456'</span> <span class="token operator">|</span> chpasswd<span class="token punctuation">;</span> <span class="token punctuation">\</span><span class="token function">useradd</span> juhaozero<span class="token punctuation">;</span> <span class="token punctuation">\</span>/bin/echo <span class="token string">'juhaozero:123456'</span> <span class="token operator">|</span> chpasswd<span class="token punctuation">;</span> <span class="token punctuation">\</span>/bin/echo <span class="token parameter variable">-e</span> <span class="token string">"LANG=<span class="token entity" title="\&quot;">\"</span>en_US.UTF-8<span class="token entity" title="\&quot;">\"</span>"</span> <span class="token operator">&gt;</span> /etc/default/localEXPOSE <span class="token number">22</span>EXPOSE <span class="token number">80</span>CMD /usr/sbin/sshd <span class="token parameter variable">-D</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>开始构建镜像，注意不要在 <code>~/glory/codes/book/demo</code> 目录下放无用的文件，因为会打包所有该目录下的文件然后发送给 docker 引擎，如果文件过多会造成 build 过程缓慢</li></ol><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -t 表示指定要创建的目标镜像名</span><span class="token comment"># ~/glory/codes/book/demo 表示 Dockerfile 文件所在的目录</span><span class="token function">docker</span> build <span class="token parameter variable">-t</span> juhaozero/centos:8.0 ~/glory/codes/book/demo<span class="token comment"># 查看已经构建好的镜像信息</span><span class="token function">docker</span> images<span class="token comment"># 使用新的镜像来创建新容器</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> juhaozero/centos:8.0 <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>设置镜像标签</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 先查看镜像</span>$ <span class="token function">docker</span> images                                                                   REPOSITORY            TAG                       IMAGE ID       CREATED          SIZEjuhaozero/centos           <span class="token number">8.0</span>                       594ab4747ed4   <span class="token number">14</span> minutes ago   210MB<span class="token comment"># 设置镜像标签</span>$ <span class="token function">docker</span> tag 594ab4747ed4 juhaozero1/centos1:8.1.1<span class="token comment"># 再次查看镜像信息会多一个标签</span>$ <span class="token function">docker</span> imagesREPOSITORY            TAG                       IMAGE ID       CREATED          SIZEjuhaozero/centos           <span class="token number">8.0</span>                       594ab4747ed4   <span class="token number">14</span> minutes ago   210MBjuhaozero1/centos1         <span class="token number">8.1</span>.1                     594ab4747ed4   <span class="token number">14</span> minutes ago   210MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="容器相关的命令"><a href="#容器相关的命令" class="headerlink" title="容器相关的命令"></a>容器相关的命令</h2><ul><li>查看容器的系统版本信息</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 进入容器后执行</span><span class="token function">cat</span> /proc/version<span class="token comment"># 比如会输出以下内容</span>Linux version <span class="token number">4.19</span>.121-linuxkit <span class="token punctuation">(</span>root@18b3f92ade35<span class="token punctuation">)</span> <span class="token punctuation">(</span>gcc version <span class="token number">9.2</span>.0 <span class="token punctuation">(</span>Alpine <span class="token number">9.2</span>.0<span class="token punctuation">))</span> <span class="token comment">#1 SMP Thu Jan 21 15:36:34 UTC 2021</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>查看所有的容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span><span class="token comment"># 或者使用以下命令，是一样的效果</span><span class="token function">docker</span> container <span class="token function">ls</span> <span class="token parameter variable">-a</span><span class="token comment"># 查看最后一次创建的容器</span><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-l</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>查看所有已经运行的容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">ps</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看容器端口映射</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> port <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>查看 docker 底层信息（比如：查看指定容器的 ip 地址）</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 查看 docker 容器的配置和状态信息</span><span class="token function">docker</span> inspect <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span> <span class="token comment"># 查看容器的 ip 地址</span><span class="token function">docker</span> inspect <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token function">grep</span> IPAddress<span class="token comment"># 比如查看容器 id 为 66204be9fe65 的容器所对应的 ip 地址</span><span class="token function">docker</span> inspect 66204be9fe65 <span class="token operator">|</span> <span class="token function">grep</span> IPAddress<span class="token comment"># 比如查看容器名称为 juhaozero 所对应的 ip 地址</span><span class="token function">docker</span> inspect juhaozero <span class="token operator">|</span> <span class="token function">grep</span> IPAddress<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>创建容器并把镜像恢复到容器当中，且启动容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token punctuation">[</span>-i<span class="token punctuation">]</span><span class="token punctuation">[</span>-t<span class="token punctuation">]</span><span class="token punctuation">[</span>-v<span class="token punctuation">]</span><span class="token punctuation">[</span>--name<span class="token punctuation">]</span><span class="token punctuation">[</span>-d<span class="token punctuation">]</span><span class="token punctuation">[</span>-p<span class="token punctuation">]</span><span class="token comment"># -i 表示 interactive 交互式</span><span class="token comment"># -t 表示得到一个 terminal</span><span class="token comment"># --name 表示修改容器名称</span><span class="token comment"># -d 表示以守护进程的方式运行（默认不会进入容器，想要进入容器则需要使用 docker exec 命令）</span><span class="token comment"># -p 表示 **指定** 映射端口</span><span class="token comment"># -P （大写的字母 p ） 表示 **随机** 映射端口</span><span class="token comment"># /bin/bash 和 bash 等效</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token operator">&lt;</span>image-name<span class="token operator">&gt;</span> /bin/bash<span class="token comment"># 比如创建一个新容器并且进入 ubuntu:16.04 镜像</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> ubuntu:16.04 <span class="token function">bash</span><span class="token comment"># 或者</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> ubuntu:16.04 /bin/bash<span class="token comment"># 或者</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> ubuntu:16.04<span class="token comment"># 以 centos 镜像创建一个新容器，并修改新容器名称为 juhaozero-container</span><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> juhaozero-container centos <span class="token function">bash</span>  <span class="token comment"># 以守护进程的方式运行 （后台运行）</span><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--name</span> juhaozero-container centos  <span class="token comment"># 或者</span><span class="token function">docker</span> run <span class="token parameter variable">-di</span> <span class="token parameter variable">--name</span> juhaozero-container centos<span class="token comment"># 指定容器绑定的网络地址，这样我们就可以通过访问 127.0.0.1:5001 来访问容器的 5000 端口（默认绑定的都是 tcp 端口）</span><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">127.0</span>.0.1:5001:5000 centos:8.0 <span class="token function">bash</span><span class="token comment"># 如果需要绑定 udp 端口，则</span><span class="token comment"># （还可以进入容器就直接执行 python app.py 命令）</span><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">127.0</span>.0.1:5001:5000/udp centos:8.0 python app.py<span class="token comment"># 比如，安装 hyperf 镜像并启动容器</span><span class="token comment"># 如果 docker 启动时开启了 selinux-enabled 选项，容器内访问宿主机资源就会受限，所以启动容器时可以增加 --privileged -u root 选项</span><span class="token function">docker</span> run <span class="token parameter variable">--name</span> hyperf <span class="token punctuation">\</span><span class="token parameter variable">-v</span> /workspace/skeleton:/data/project <span class="token punctuation">\</span><span class="token parameter variable">-p</span> <span class="token number">9501</span>:9501 <span class="token parameter variable">-it</span> <span class="token punctuation">\</span><span class="token parameter variable">--privileged</span> <span class="token parameter variable">-u</span> root <span class="token punctuation">\</span><span class="token parameter variable">--entrypoint</span> /bin/sh <span class="token punctuation">\</span>hyperf/hyperf:7.4-alpine-v3.11-swoole<span class="token comment"># 如果需要开通多个端口时，可以参考</span><span class="token function">docker</span> run <span class="token parameter variable">--name</span> api_dfo_hyperf_ws <span class="token punctuation">\</span><span class="token parameter variable">-v</span> /Users/pudongping/glory/codes/dfo/api_dfo_hyperf:/api_dfo_hyperf <span class="token punctuation">\</span><span class="token parameter variable">-p</span> <span class="token number">9502</span>:9502 <span class="token punctuation">\</span><span class="token parameter variable">-p</span> <span class="token number">9503</span>:9503 <span class="token punctuation">\</span><span class="token parameter variable">-p</span> <span class="token number">9504</span>:9504 <span class="token punctuation">\</span><span class="token parameter variable">-p</span> <span class="token number">9505</span>:9505 <span class="token parameter variable">-it</span> <span class="token punctuation">\</span><span class="token parameter variable">--entrypoint</span> /bin/sh <span class="token punctuation">\</span>juhaozero/juhaozero_api_dfo:v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>启动容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> start <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span><span class="token comment"># 比如启动容器名称为 redis-juhaozero 的容器</span><span class="token function">docker</span> start redis-juhaozero<span class="token comment"># 比如启动容器 id 为 c8c0c770ac5b 的容器</span><span class="token function">docker</span> start c8c0c770ac5b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>直接进入已经创建的容器（不会启动容器）</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> start <span class="token parameter variable">-i</span> <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span><span class="token comment"># 比如进入容器 id 为 66204be9fe65 的容器</span><span class="token function">docker</span> start <span class="token parameter variable">-i</span> 66204be9fe65<span class="token comment"># 比如进入容器名称为 juhaozero 的容器</span><span class="token function">docker</span> start <span class="token parameter variable">-i</span> juhaozero<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>重启容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> restart <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span><span class="token comment"># 比如重启容器名称为 redis-juhaozero 的容器</span><span class="token function">docker</span> restart redis-juhaozero<span class="token comment"># 比如重启容器 id 为 c8c0c770ac5b 的容器</span><span class="token function">docker</span> restart c8c0c770ac5b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>进入已经运行中的容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span> <span class="token function">bash</span><span class="token comment"># 比如进入容器名称为 redis-juhaozero 的容器</span><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> redis-juhaozero <span class="token function">bash</span><span class="token comment"># 比如进入容器 id 为 c8c0c770ac5b 的容器</span><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> c8c0c770ac5b <span class="token function">bash</span><span class="token comment"># 进入容器之后执行 shell 命令或者执行 shell 脚本</span><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span>  <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span> /bin/sh <span class="token parameter variable">-c</span> <span class="token string">"while true; do echo hello world; sleep 1; done"</span><span class="token comment"># 比如进入容器 id 为 c8c0c770ac5b 的容器，并且进入容器后执行 `bash /portal_api_dfo_hyperf/server.sh restart` 脚本</span><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> c8c0c770ac5b /bin/sh <span class="token parameter variable">-c</span> <span class="token string">"bash /portal_api_dfo_hyperf/server.sh restart"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>停止容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> stop <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span><span class="token comment"># 比如停止容器名称为 redis-juhaozero 的容器</span><span class="token function">docker</span> stop redis-juhaozero<span class="token comment"># 比如停止容器 id 为 c8c0c770ac5b 的容器</span><span class="token function">docker</span> stop c8c0c770ac5b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>退出容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">exit</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>删除容器</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">rm</span> <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span><span class="token comment"># 也可以加入 -f 参数，强制移除正在运行中的容器</span><span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> 1e560fca3906<span class="token comment"># 清理掉所有处于终止状态的容器</span><span class="token function">docker</span> container prune<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>修改容器名称</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">rename</span> <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>new-container-name<span class="token operator">&gt;</span><span class="token comment"># 比如将容器 redis-juhaozero 改名为 redis-tt</span><span class="token function">docker</span> <span class="token function">rename</span> redis-juhaozero redis-tt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>查看容器的标准输出</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> logs <span class="token operator">&lt;</span>container-name or container-id<span class="token operator">&gt;</span><span class="token comment"># 比如查看容器 id 为 c8c0c770ac5b 的容器标准输出内容</span><span class="token function">docker</span> logs c8c0c770ac5b<span class="token comment"># 也可以加入 -f 参数，像使用 tail -f 一样来输出容器内部的标准输出</span><span class="token function">docker</span> logs <span class="token parameter variable">-f</span> c8c0c770ac5b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="容器与宿主机之间的文件或者目录拷贝"><a href="#容器与宿主机之间的文件或者目录拷贝" class="headerlink" title="容器与宿主机之间的文件或者目录拷贝"></a>容器与宿主机之间的文件或者目录拷贝</h2><ul><li>从宿主机拷贝文件到容器中</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">cp</span> <span class="token operator">&lt;</span>local-directory-or-file<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>container-name<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>container-directory-or-file<span class="token operator">&gt;</span><span class="token comment"># 比如将宿主机中的 /home/juhaozero/test.txt 文件拷贝到 centos1 容器中的 /test.txt</span><span class="token function">docker</span> <span class="token function">cp</span> /home/juhaozero/test.txt centos1:/test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>从容器拷贝到宿主机中</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">cp</span> <span class="token operator">&lt;</span>container-name<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>container-directory-or-file<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>local-directory<span class="token operator">&gt;</span><span class="token comment"># 比如将 centos1 容器中的 /test 目录拷贝到宿主机的 /home/juhaozero 目录下</span><span class="token function">docker</span> <span class="token function">cp</span> centos1:/test /home/juhaozero<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="目录挂载（创建容器的时候就需要进行目录挂载）"><a href="#目录挂载（创建容器的时候就需要进行目录挂载）" class="headerlink" title="目录挂载（创建容器的时候就需要进行目录挂载）"></a>目录挂载（创建容器的时候就需要进行目录挂载）</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">-di</span> <span class="token parameter variable">-v</span> <span class="token operator">&lt;</span>local-directory<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>container-directory<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>image-name<span class="token operator">&gt;</span><span class="token comment"># 在 windows 下挂载（注意路径的书写方式）</span><span class="token comment"># 比如以 centos 镜像创建一个容器，并将本地 D 盘中的 juhaozero 目录，挂载到容器中的 /usr/local/demo 目录</span><span class="token function">docker</span> run <span class="token parameter variable">-di</span> <span class="token parameter variable">-v</span> d:<span class="token punctuation">\</span>juhaozero:/usr/local/demo centos<span class="token comment"># 在 linux 下挂载</span><span class="token comment"># 比如以 centos 镜像创建一个容器，并将本地的 /home/juhaozero/juhaozero 目录，挂载到容器中的 /usr/local/demo 目录</span><span class="token function">docker</span> run <span class="token parameter variable">-di</span> <span class="token parameter variable">-v</span> /home/juhaozero/juhaozero:/usr/local/demo centos<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h2><ul><li>导出容器快照</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">export</span> <span class="token operator">&lt;</span>container-id<span class="token operator">&gt;</span> <span class="token operator">&gt;</span> <span class="token operator">&lt;</span>your-backup-name.tar<span class="token operator">&gt;</span><span class="token comment"># 比如将容器 id 为 7691a814370e 的容器导出快照为 juhaozero.tar</span><span class="token function">docker</span> <span class="token builtin class-name">export</span> 7691a814370e <span class="token operator">&gt;</span> juhaozero.tar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>导入容器快照</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token operator">&lt;</span>your-backup-name.tar<span class="token operator">&gt;</span> <span class="token operator">|</span> <span class="token function">docker</span> <span class="token function">import</span> - <span class="token operator">&lt;</span>image-author-name<span class="token operator">&gt;</span>/<span class="token operator">&lt;</span>your-new-image-name<span class="token operator">&gt;</span>:<span class="token operator">&lt;</span>your-new-image-version<span class="token operator">&gt;</span><span class="token comment"># 比如将容器快照文件 juhaozero.tar 导入到 juhaozero-demo 镜像并定义 juhaozero-demo 镜像的作者为 juhaozero，版本号为 v1.0</span><span class="token function">cat</span> juhaozero.tar <span class="token operator">|</span> <span class="token function">docker</span> <span class="token function">import</span> - juhaozero/juhaozero-demo:v1.0<span class="token comment"># 此外，也可以通过指定 url 或者某个目录来导入</span><span class="token function">docker</span> <span class="token function">import</span> http://example.com/example-image.tgz example/image-repo:v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 密钥登录</title>
      <link href="posts/1c226d39.html"/>
      <url>posts/1c226d39.html</url>
      
        <content type="html"><![CDATA[<h2 id="何为密钥登录"><a href="#何为密钥登录" class="headerlink" title="何为密钥登录 ?"></a><strong>何为密钥登录 ?</strong></h2><p>SHH 密钥对通过<strong>加密算法</strong>生成一对密钥，默认采用 RSA 2048 位的加密方式，生成的密钥是一个对外界公开，称为公钥，另一个用户自己保留，称为私钥，这种方式可使服务器的登录认证更加安全可靠。<br>简单讲类似于门锁的结构，但这把门锁有其唯一性，服务器使用密钥登录，没有私钥任何人都无法直接登录，可以杜绝暴力破解威胁</p><table><thead><tr><th>常用参数</th><th>说明</th></tr></thead><tbody><tr><td>-t</td><td>指定生成密钥的类型，RSA和DSA(默认使用RSA算法 ) 算法有rsa1”(SSH-1) “rsa”(SSH-2) “dsa”(SSH-2)</td></tr><tr><td>-f</td><td>指定生成密钥的文件名，默认id_rsa（私钥id_rsa，公钥id_rsa.pub）</td></tr><tr><td>-P</td><td>提供旧密码，空表示不需要密码（-P ‘’）</td></tr><tr><td>-N</td><td>提供旧密码，空表示不需要密码（-P ‘’）</td></tr><tr><td>-b</td><td>指定密钥长度（bits），RSA最小要求768位，默认是2048位；DSA密钥必须是1024位（FIPS 1862标准规定）</td></tr><tr><td>-C</td><td>提供一个新注释</td></tr><tr><td>-R</td><td>hostname：从known_hosta（第一次连接时就会在家目录.ssh目录下生产该密钥文件）文件中删除所有属于hostname的密钥</td></tr></tbody></table><h2 id="生成密钥对并使用密钥认证登录"><a href="#生成密钥对并使用密钥认证登录" class="headerlink" title="生成密钥对并使用密钥认证登录"></a>生成密钥对并使用密钥认证登录</h2><h6 id="在Linux服务器上的-ssh目录下（-ssh文件夹为隐藏文件夹-ll-a-可查看）"><a href="#在Linux服务器上的-ssh目录下（-ssh文件夹为隐藏文件夹-ll-a-可查看）" class="headerlink" title="在Linux服务器上的 .ssh目录下（.ssh文件夹为隐藏文件夹 ll -a 可查看）"></a>在Linux服务器上的 .ssh目录下（.ssh文件夹为隐藏文件夹 ll -a 可查看）</h6><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#生成一个rsa算法加密的 2048位的密钥对</span>ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-b</span> <span class="token number">2048</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h6 id="如不需要指定密码，直接按三次确认即可"><a href="#如不需要指定密码，直接按三次确认即可" class="headerlink" title="如不需要指定密码，直接按三次确认即可"></a>如不需要指定密码，直接按三次确认即可</h6><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20210513202553923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70"></p><h6 id="ssh目录下会有一个-authorized-keys文件，没有自己创建即可"><a href="#ssh目录下会有一个-authorized-keys文件，没有自己创建即可" class="headerlink" title=".ssh目录下会有一个 authorized_keys文件，没有自己创建即可"></a>.ssh目录下会有一个 authorized_keys文件，没有自己创建即可</h6><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20210513202913870.png"></p><h6 id="下载私钥到自己电脑上！！！！"><a href="#下载私钥到自己电脑上！！！！" class="headerlink" title="下载私钥到自己电脑上！！！！"></a>下载私钥到自己电脑上！！！！</h6><h6 id="下载私钥到自己电脑上！！！！-1"><a href="#下载私钥到自己电脑上！！！！-1" class="headerlink" title="下载私钥到自己电脑上！！！！"></a>下载私钥到自己电脑上！！！！</h6><h6 id="下载私钥到自己电脑上！！！！-2"><a href="#下载私钥到自己电脑上！！！！-2" class="headerlink" title="下载私钥到自己电脑上！！！！"></a>下载私钥到自己电脑上！！！！</h6><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#将生成的公钥复制到该文件下</span><span class="token function">cat</span> id_rsa.pub <span class="token operator">&gt;&gt;</span> authorized_keys<span class="token comment">#为文件和文件夹设置权限，部分权限不足可致无法登录</span><span class="token function">chmod</span> <span class="token number">700</span> .ssh<span class="token function">chmod</span> <span class="token number">600</span> .ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h6 id="ssh服务端配置sshd-config"><a href="#ssh服务端配置sshd-config" class="headerlink" title="ssh服务端配置sshd_config"></a>ssh服务端配置sshd_config</h6><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">vim <span class="token operator">/</span>etc/ssh/sshd_config  <span class="token comment">#禁用SSH密码验证</span>PasswordAuthentication no<span class="token comment">#是否允许公钥认证。仅可以用于SSH-2。默认值为"yes"。</span>PubkeyAuthentication yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="在自己的Linux远程服务端选择密钥连接。选择私钥即可"><a href="#在自己的Linux远程服务端选择密钥连接。选择私钥即可" class="headerlink" title="在自己的Linux远程服务端选择密钥连接。选择私钥即可"></a>在自己的Linux远程服务端选择密钥连接。选择私钥即可</h5><p>==需保证创建密钥对和登录是同一个用户，不同用户将公钥复制到该用户的.ssh文件夹下的authorized_keys 即可 ==</p><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20210513204410393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70"></p><p>参考文章<br><a href="https://blog.51cto.com/u_13691477/2121696">ssh-keygen常用参数详解</a><br><a href="https://blog.csdn.net/baidu_35287211/article/details/82115016">ssh密钥登录linux</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux 命令</title>
      <link href="posts/85903493.html"/>
      <url>posts/85903493.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h1><h5 id="目录切换"><a href="#目录切换" class="headerlink" title="目录切换"></a>目录切换</h5><p><code>cd .</code>  当前目录<br><code>cd ..</code> 返回上一级目录<br><code>cd-</code>返回上一次目录<br><code>cd~</code> 返回当前主目录</p><h5 id="创建目录和查看目录"><a href="#创建目录和查看目录" class="headerlink" title="创建目录和查看目录"></a>创建目录和查看目录</h5><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>mkdir 目录名</td><td>创建目录</td></tr><tr><td>mkdir [-p] 目录名</td><td>如果父目录不存在先创建父目录，之后再创建子目录</td></tr><tr><td>ls</td><td>显示当前目录下的文件和目录</td></tr><tr><td>ls-l</td><td>以详细的方式显示当前目录下的文件和目录</td></tr><tr><td>ls-a</td><td>显示当前目录下所有的文件和目录，包含隐藏的文件和目录。</td></tr></tbody></table><h5 id="重命名、移动、复制"><a href="#重命名、移动、复制" class="headerlink" title="重命名、移动、复制"></a>重命名、移动、复制</h5><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>mv 旧文件名 新文件名</td><td>重命名文件名/</td></tr><tr><td>mv  源目录  目标目录</td><td>移动（存在文件名则移动，不存在则重命名）</td></tr><tr><td>cp -r  源文件或目录 目标目录</td><td>所有的文件全部复制</td></tr></tbody></table><h5 id="删除（谨慎操作）"><a href="#删除（谨慎操作）" class="headerlink" title="删除（谨慎操作）"></a>删除（谨慎操作）</h5><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>rm -r 目录名称</td><td>删除目录，可以同时指定多个（删除前需要确定）</td></tr><tr><td>rm -r 文件或目录</td><td>名称 强制删除，删除前不会有提问</td></tr><tr><td>rm -rf 文件或目录名称</td><td>强制删除文件或目录</td></tr><tr><td>rm -rf /*</td><td>删除所有的文件或目录（千万不要用）</td></tr><tr><td><img src="/medias/loading.gif" data-original="https://imgconvert.csdnimg.cn/aHR0cDovLzViMDk4OGU1OTUyMjUuY2RuLnNvaHVjcy5jb20vaW1hZ2VzLzIwMTgwOTIyLzIxODlmOTE5MTYzMTRhZmFhYzQ2ZWJhNmU2MWUzNTU2LmpwZWc?x-oss-process=image/format,png" alt="在这里插入图片描述"></td><td></td></tr></tbody></table><h4 id="创建文件、查看文件内容"><a href="#创建文件、查看文件内容" class="headerlink" title="创建文件、查看文件内容"></a>创建文件、查看文件内容</h4><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>touch  文件</td><td>创建一个或多个文件</td></tr><tr><td>cat 文件名称</td><td>查看文件所有的内容</td></tr><tr><td>more 文件名称</td><td>查看文件所有的内容，可以分屏显示</td></tr><tr><td>head 文件名称</td><td>查看文件前 10 行</td></tr><tr><td>head -n  行数  文件名</td><td>查看前面指定的行数</td></tr><tr><td>tail  文件名</td><td>查看文件后 10 行</td></tr><tr><td>tail -n  行数  文件名</td><td>查看文件后指定的行数</td></tr><tr><td>less  文件名</td><td>查看文件所有的内容</td></tr><tr><td>less -N 文件名</td><td>查看文件所有的内容（显示行数）</td></tr></tbody></table><h2 id="解压和打包压缩命令"><a href="#解压和打包压缩命令" class="headerlink" title="解压和打包压缩命令"></a>解压和打包压缩命令</h2><p> <strong>压缩</strong></p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>tar-c</td><td>创建打包文件</td></tr><tr><td>tar-v</td><td>打包文件</td></tr><tr><td>tar-z</td><td>压缩文件</td></tr><tr><td>tar-f</td><td>压缩文件名</td></tr><tr><td>tar -cvzf 新的文件名.tar.gz 打包的文件</td><td>打包并压缩文件并设置名字</td></tr></tbody></table><p><strong>解压</strong></p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>tar -x</td><td>解压指定文件</td></tr><tr><td>tar-v</td><td>显示解压详细过程</td></tr><tr><td>tar-f</td><td>指定解压的文件</td></tr><tr><td>tar-C</td><td>解压到指定目录下</td></tr><tr><td>tar -xvf 解压的文件  -C 解压的位置</td><td>解压到指定位置并展现详细过程</td></tr></tbody></table><h2 id="Vim命令"><a href="#Vim命令" class="headerlink" title="Vim命令"></a>Vim命令</h2><h5 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h5><p>可以<strong>移动光标、删除字符等操作</strong>，打开文件时即进入这个模式</p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>vim 文件名字</td><td>打开文件</td></tr><tr><td>i</td><td>在当前光标的前面插入字符</td></tr><tr><td>a</td><td>在当前光标的后面插入字符</td></tr><tr><td>o</td><td>在当前光标的下一行插入字符</td></tr><tr><td>yy</td><td>复制当前行</td></tr><tr><td>p</td><td>如果前面已经复制了，在当前下面粘贴</td></tr><tr><td>u</td><td>撤销</td></tr><tr><td>/</td><td>搜索文本</td></tr></tbody></table><h5 id="底行模式"><a href="#底行模式" class="headerlink" title="底行模式"></a>底行模式</h5><p>可以输入命令<strong>对编辑的文件进行查找，保存，退出等操作</strong></p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>wq</td><td>保存并退出</td></tr><tr><td>q!</td><td>不保存强制退出</td></tr><tr><td>wq!</td><td>强制保存退出</td></tr></tbody></table><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><p><strong>主机名配置</strong></p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>hostname</td><td>获取主机名</td></tr><tr><td>hostname 新主机名</td><td>修改主机名、单次有效</td></tr><tr><td>hostnamectl set -hostname 新主机名</td><td>修改主机名，永久有效</td></tr></tbody></table><p><strong>查询网络进程</strong></p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>netstat</td><td>显示网络状态</td></tr><tr><td>netstat -n</td><td>显示程序中的ip地址和端口号</td></tr><tr><td>netstat -t</td><td>只显示Tcp协议的连接</td></tr><tr><td>netstat -l</td><td>显示监听中的 Socket</td></tr><tr><td>netstat-p</td><td>显示程序的名字</td></tr><tr><td>netstat -nutlp</td><td>以上全部都显示</td></tr></tbody></table><p><strong>防火墙配置</strong></p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>systemctl status firewalld</td><td>查看防火墙的状态</td></tr><tr><td>systemctl start firewalld</td><td>开启防火墙</td></tr><tr><td>systemctl stop firewalld</td><td>关闭防火墙</td></tr><tr><td>systemctl enable firewalld</td><td>开机自启</td></tr><tr><td>systemctl disable firewalld</td><td>开机不自启</td></tr><tr><td>systemctl restart firewalld</td><td>重启防火墙</td></tr><tr><td>firewall-cmd –zone=public –add-port= 端口/tcp –permanent</td><td>开放端口允许外部连接</td></tr></tbody></table><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>pwd</td><td>打印当前的工作目录</td></tr><tr><td>ps-aux</td><td>显示当前用户的所有进程</td></tr><tr><td>kill -9 进程号</td><td>杀死进程</td></tr><tr><td>free -m</td><td>查看系统内存的使用情况</td></tr><tr><td>shutdown now</td><td>关闭服务器</td></tr><tr><td>reboot</td><td>重启服务器</td></tr></tbody></table><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>个人博客：<a href="https://juhaozero.github.io/"> juhaozero的博客 </a><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109205044873.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 入门</title>
      <link href="posts/49f1e1db.html"/>
      <url>posts/49f1e1db.html</url>
      
        <content type="html"><![CDATA[<h5 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h5><p>本来想年后再写，但遇上了肺炎的爆发，抽空乱写吧！大家出门记得戴口罩啊！！关于docker，这边也只学了个大概，凑合看吧！，有不对的地方欢迎指正</p><h2 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h2><blockquote><p>Docker是一个开放源代码软件项目，让应用程序部署在软件货柜下的工作可以自动化进行，借此在Linux操作系统上，提供一个额外的软件抽象层，以及操作系统层虚拟化的自动管理机制。</p></blockquote><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200106210850161.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "><br>之前我们部署项目是在Linux上部署的，而利用docker我们可以在docker上部署，而docker部署在Linux上，那Linux上可以部署多个docker，也就是说我们可以部署多个项目，启动多个Tomcat。</p><h3 id="Docker的特点"><a href="#Docker的特点" class="headerlink" title="Docker的特点"></a>Docker的特点</h3><p><strong>1. 秒级的交付和部署<br> 2. 保证环境一致性<br> 3. 动态调度迁移成本低</strong></p><h2 id="关于Docker的几个概念"><a href="#关于Docker的几个概念" class="headerlink" title="关于Docker的几个概念"></a>关于Docker的几个概念</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>Docker的镜像类似于软件的安装包，镜像相当于把整个的系统环境打包起来，只要解压即可使用的这样一种状态，镜像是只读的</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器是基于镜像存在的，它是真正运行项目的一层，容器装载着应用，应用基于容器存在，我们可以将项目部署到应用上，如果将镜像比做一台电脑的话，容器就是镜像中的虚拟机，每个容器都是相互隔离的，互不干扰。</p><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>仓库用于存放镜像，像<a href="https://hub.docker.com/">Docker的中央仓库</a>，可以从Docker下载各个环境，软件的镜像。</p><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>systemctl start docker</td><td>启动docker</td></tr><tr><td>systemctl stop docker</td><td>停止docker</td></tr><tr><td>systemctl restart docker</td><td>重启docker</td></tr><tr><td>systemctl status docker</td><td>查看docker状态</td></tr><tr><td>systemctl enable diocker</td><td>查看docker状态</td></tr><tr><td>docker info</td><td>查看docker概要信息</td></tr><tr><td>docker –help</td><td>查看docker帮助文档</td></tr></tbody></table><p>查看状态<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200208182415953.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>docker images</td><td>查看镜像</td></tr><tr><td>docker search 镜像名称</td><td>搜索镜像</td></tr><tr><td>docker pull 镜像名称</td><td>向中央仓库拉取镜像</td></tr><tr><td>docker rmi 镜像ID/镜像名称</td><td>删除镜像</td></tr><tr><td>docker rmi docker images -q</td><td>删除所有镜像</td></tr></tbody></table><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200208183325671.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>docker ps</td><td>查看运行中的容器</td></tr><tr><td>docker ps -a</td><td>查看所有容器</td></tr><tr><td>docker ps -l</td><td>查看最后一次运行的容器</td></tr><tr><td>docker start 容器名称/容器ID</td><td>启动容器</td></tr><tr><td>docker stop 容器名称/容器ID</td><td>停止容器</td></tr><tr><td>docker restart 容器名称/容器ID</td><td>重启容器</td></tr></tbody></table><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200208184256936.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>docker run -it –name=创建的容器名称 /bin /bash</td><td>创建容器，创建后直接进入容器</td></tr><tr><td>docker run  -dt –name=创建的容器名称 /bin /bash</td><td>创建容器</td></tr><tr><td>exit</td><td>退出容器</td></tr></tbody></table><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>删除容器</td><td>docker rm 容器名称/容器ID</td></tr><tr><td>docker rm -f 容器名称</td><td>强制删除容器</td></tr></tbody></table><p>未完待续！！！！</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> CentOS </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ入门</title>
      <link href="posts/bae9a0d2.html"/>
      <url>posts/bae9a0d2.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h2><blockquote><p>消息队列（英语：Message queue）是一种进程间通信或同一进程的不同线程间的通信方式，软件的贮列用来处理一系列的输入，通常是来自用户。消息队列提供了异步的通信协议，每一个贮列中的纪录包含详细说明的数据，包含发生的时间，输入设备的种类，以及特定的输入参数，也就是说：消息的发送者和接收者不需要同时与消息队列交互。消息会保存在队列中，直到接收者取回它。y</p></blockquote><p>简单点说：<strong>消息队列是应用程序和应用程序之间的通信方法</strong>。当我们将大项目拆分为许多许多小模块时，我们在这些模块中需要通信时，利用传统的做法就是通过网络调用，这种做法在遇到<strong>高并发</strong>、<strong>网络异常</strong>的情况下，所带来的情况便是响应时间的变长，及可能带来服务的失败。<br>这时我们就要使用上<strong>消息队列</strong>了。我们可将一些<strong>无需即时返回且耗时的操作提取出来</strong>，进行<strong>异步处理</strong>，而这种异步处理的方式大大的节省了服务器的请求响应时间，从而<strong>提高了系统的吞吐量</strong>。<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200113172656348.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><h2 id="消息队列的好处"><a href="#消息队列的好处" class="headerlink" title="消息队列的好处"></a>消息队列的好处</h2><h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><p><strong>消息队列相当于一个中介，生产方通过j消息队列与消费方交互，消息队列将生产者和消费者的依赖关系分离开，实现了解耦合</strong>，消费方无须关心生存方一方的的业务，只需得到相应的通知，然后就会去做对应的事，这样各个模块之间就解耦了。</p><h4 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h4><p><strong>将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理</strong>。当我们去执行一段业务时，我们需要通过网络调用另一段与主线业务无关的业务时，我们可以利用消息队列，将这一段业务交给消息队列去执行，我们只需执行完主线业务然后返回结果即可。<br>举个例子：当我们需要执行【注册业务】时，我们需要执行【发短信业务】,可【发短信业务】所带来的时间，是非常非常久的，这时，我们便可以将【发短信业务】放在消息队列中，从而不会拖慢【注册业务】的时间。</p><h4 id="削峰-x2F-限流"><a href="#削峰-x2F-限流" class="headerlink" title="削峰/限流"></a>削峰/限流</h4><p><strong>让消息不直接到达服务器，先让消息队列保存这些数据，减少同一时刻对服务器的压力</strong>。当同一时刻的请求激增时，我们可以将生产者的请求存储在消息队列中，限制消费方消费消息的速度，这样一来,当出现请求高峰期的时候，不至于将服务器压垮，这种我们就叫<strong>削峰</strong><br>举个例子：【订单系统】当高峰期所达到的高并发足以压垮服务器时，我们可以将下单的请求存到消息队列中，限制服务器的请求量。</p><h2 id="消息队列的实现方式"><a href="#消息队列的实现方式" class="headerlink" title="消息队列的实现方式"></a>消息队列的实现方式</h2><h4 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h4><blockquote><p>Java消息服务（Java Message Service，JMS）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。<br>JMS在特定的API接口层面和实现行为上进行了统一。</p></blockquote><h4 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h4><blockquote><p>高级消息队列协议即Advanced Message Queuing Protocol（AMQP）是面向消息中间件提供的开放的应用层协议。AMQP规范了消息传递方和接收方的行为，以使消息在不同的提供商之间实现互操作性，就像SMTP，HTTP，FTP等协议可以创建交互系统一样。高级消息队列协议关注于各种消息如何以字节流的形式进行传递。因此，使用了符合协议实现的任意应用程序之间可以保持对消息的创建、传递。</p></blockquote><p>简单点说：JMS定义接口来实现，AMQP通过协议实现，AMQP可以通过网络来传递，因此AMQP是跨语言的</p><h2 id="消息队列产品"><a href="#消息队列产品" class="headerlink" title="消息队列产品"></a>消息队列产品</h2><p>ActiveMQ<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200113181914932.jpg" alt=" "><br>ZMQ:<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200113181931240.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "><br>RabbitMQ:<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200113182004236.jpg" alt=" "><br>RockerMQ:<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200113182014703.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "><br>Kafka:</p><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200113182015119.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><blockquote><p>RabbitMQ是由erlang语言开发，基于AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列，它是一种应用程序之间的通信方法，消息队列在分布式系统开发中应用非常广泛。</p></blockquote><p><a href="http://www.rabbitmq.com/">RabbitMQ官方地址</a><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/2020011318234869.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><p>RabbitMQ提供了7种模式：<strong>简单模式，工作队列模式，发布与订阅模式，路由模式，通配符模式，RPC模式，发布者确认模式。</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200113183039103.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "><br>关于RabbitMQ的下载和安装，官网一步到位，这里就不做说明了<br>当我们下载安装完RabbitMQ后（<strong>RabbitMQ的默认账号是guest 密码 guest  默认端口15672</strong>）<br>访问RabbitMQ的网址，看到以下画面即为成功安装。<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200113185803418.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><h3 id="RabbitMQ的几个概念"><a href="#RabbitMQ的几个概念" class="headerlink" title="RabbitMQ的几个概念"></a>RabbitMQ的几个概念</h3><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200114161354126.jpg" alt=" "></p><h4 id="Connection-连接-："><a href="#Connection-连接-：" class="headerlink" title="Connection(连接)："></a>Connection(连接)：</h4><p>基于AMQP协议的网络连接，比如TCP/IP套接字连接。当使用RabbitMQ时便会创建连接，开启信道，连接到RabbitMQ，当消息发送完毕便会关闭信道、关闭连接。</p><h4 id="Channel（信道"><a href="#Channel（信道" class="headerlink" title="Channel（信道):"></a>Channel（信道):</h4><p>RabbitMQ之间使用 TCP 连接，加入每次发布消息都要连接TCP，这不仅会造成连接资源严重浪费，RabbitMQ 引入了信道的概念，所有需要发布消息的线程都包装成一条信道在 TCP 中传输，理论上 一条 TCP 连接支持无限多个信道。<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200114162613865.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><h4 id="Exchanges-交换机-："><a href="#Exchanges-交换机-：" class="headerlink" title="Exchanges(交换机)："></a>Exchanges(交换机)：</h4><p>在Rabbit的几种模式中，从发布订阅模式开始便引入了交换机这一概念，利用交换机，将消息存放在交换机中，<strong>由交换机将消息转发到绑定此交换机的每个队列，每个绑定交换机的队列都将接收消息</strong>，做到了一条消息多个共享。</p><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200114164652843.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><h4 id="Queues（队列"><a href="#Queues（队列" class="headerlink" title="Queues（队列):"></a>Queues（队列):</h4><p>用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。<strong>一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200114164645720.jpg" alt="  "></p><h4 id="virtual-host（域）"><a href="#virtual-host（域）" class="headerlink" title="virtual_host（域）"></a>virtual_host（域）</h4><p>域是rabbitmq分配权限的最小细粒度。比如我们可以为一个用户分配一个可以访问哪个域。所以可以多个user共同使用一个virtual host，不同的命名空间之间的资源是不能访问的。<strong>域是一个权限的标记，标记用户访问的权限</strong></p><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/202001211754117.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p><strong>依赖</strong></p><h5 id="消费者和生产者依赖相同"><a href="#消费者和生产者依赖相同" class="headerlink" title="消费者和生产者依赖相同"></a>消费者和生产者依赖相同</h5><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121174430209.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><p><strong>配置文件</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/2020012117444826.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><p>在RabbitMQ的官方文档中，我们可以看到我们需要发送方和接收方。为了方便，这里统一使用SpringBoot整合RabbitMQ，SpringBoot为我们解决了繁琐的创建过程，其他方式差不多一样，有兴趣可以到官方文档中查看，这里就不一一演示。<strong>这里讲几个典型的，其他可参考官方文档</strong>。</p><blockquote><p>我们将调用消息发布者(发送方)Send和消息使用者(接收方)Recv。发布者将连接到RabbitMQ，发送一条消息，然后退出。在发送。java，我们需要导入一些类</p></blockquote><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121151212815.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><h3 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h3><p><strong>一个生产者、一个消费者，依靠队列交换消息，队列相当于一个中转站</strong></p><ul><li>P：生产者： 发送消息到队列</li><li>C：消费者： 消费队列中的消息</li><li>Queue：消息队列，接收消息、缓存消息。<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121175720387.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></li></ul><p><strong>生产者</strong><br><strong>模拟一个消息的发送</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/2020012118424921.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><p><strong>配置类</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121182225477.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><p><strong>启动看效果</strong></p><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121173109580.jpg" alt=" "><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121173127867.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "><br>我们可以看到在RabbitMQ的页面上生成了<strong>信道和队列</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121173312403.jpg" alt=" "><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121173341950.jpg" alt=" "><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121173416197.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "><br><strong>消费者</strong></p><p><strong>监听队列</strong></p><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121182118896.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70"><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121173908608.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "><br>到这里简单模式的的入门就到处为止了。<br><strong>简单模式是里面典型的一种模式，指不加入交换机，单点对单点的这种形式，这种模式的缺点就是一个消息就只能由一个消费，，不能做到多个消费者共用同一个消息，这种模式还有工作队列模式，工作队列只不过在简单模式的基础上有多个消费者而已，因此就不做演示。</strong></p><h3 id="发布与订阅模式"><a href="#发布与订阅模式" class="headerlink" title="发布与订阅模式"></a>发布与订阅模式</h3><p> P：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）<br> C：消费者， 消费队列中的消息。<br> Queue：消息队列，接收消息、缓存消息。<br>X：- <strong><font color="red">Exchange</font></strong><font color="red">：</font>交换机，。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如把消息递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有常见以下3种类型：</p><ul><li><strong><font color="red">Fanout</font></strong><font color="red">：</font>广播，将消息交给所有绑定到交换机的队列</li><li><strong><font color="red">Direct</font></strong><font color="red">：</font>定向，把消息交给符合指定routing key 的队列</li><li><strong><font color="red">Topic</font></strong><font color="red">：</font>通配符，把消息交给符合的队列，模糊匹配。<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121175903391.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "><br><strong>绑定交换机</strong></li></ul><p>第二个参数为路由模式的参数，如无，为空即可<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121192056761.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><p><strong>配置类</strong></p><p>·配置交换机<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121190453881.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><p><strong>消费者（编写两个消费者）</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121193915334.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "></p><p><strong>绑定队列和交换机</strong></p><p>启动后在RabbitMQ中生成了新的交换机和新的信道<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121193857797.jpg" alt=" "><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121190934512.jpg" alt="  "></p><p>启动测试<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121192244812.jpg" alt="  "></p><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>路由模式即多了一个路由的key，只有拥有指定路由key的消费者才可以访问</p><p><strong>生产者</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121202232282.jpg" alt=" "></p><p><strong>配置类</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121202249453.jpg" alt=" "></p><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>在一个消费者上绑定不同的路由Key<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/202001211944000.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121202308135.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "><br>启动测试（收到不同的消息）<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121202415778.jpg" alt=" "><br>通配符模式，关于通配符模式跟路由模式差不多，只需在绑定的路由key上指定模糊匹配即可，让队列在绑定 Routing key  的时候使用。<br>匹配规则如下</p><pre class="line-numbers language-none"><code class="language-none"># 匹配一个或多个词* 匹配不多不少恰好1个词<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>关于其他的一些配置，下次再聊<br>个人博客  <a href="https://juhaozero.github.io/">juhaozero的博客</a></p><p><strong>新年快乐，明年见</strong><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200121203917897.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 入门</title>
      <link href="posts/4abc8450.html"/>
      <url>posts/4abc8450.html</url>
      
        <content type="html"><![CDATA[<h2 id="传统DB的缺点"><a href="#传统DB的缺点" class="headerlink" title="传统DB的缺点"></a>传统DB的缺点</h2><p>像Mysql、和Oracle 这种关系型数据库，虽然有着数据稳定和服务稳定、数据一致性的特点，但也存在一个致命的缺陷:</p><h4 id="高并发下DB不稳定"><a href="#高并发下DB不稳定" class="headerlink" title="高并发下DB不稳定"></a>高并发下DB不稳定</h4><p>在高并发的情况下，DB的不稳定性，在大量用户访问时DB出奇的慢，因为对磁盘操作需要使用IO流，一个字节一个字节存取操作。要将所有数据读取到内存中后才可以操作。所以在高并发下DB的<strong>高可用</strong>便成了问题。这时NoSQL便应运而生。</p><h3 id="什么是NOSQl"><a href="#什么是NOSQl" class="headerlink" title="什么是NOSQl"></a>什么是NOSQl</h3><blockquote><p>NoSQL是对不同于传统的关系数据库的数据库管理系统的统称。即非关系型数据库<br>NOSQL：因为是内存操作数据，非常快,解决了三高问题（高并发、高海量、高可用）</p></blockquote><p><strong>非关系型数据库与非关系型数据库的区别</strong></p><table><thead><tr><th>关系型数据库</th><th>非关系型数据库</th></tr></thead><tbody><tr><td>以文件方式保存</td><td>存储在内存中，服务器关闭数据可能会丢失</td></tr><tr><td>数据可以永久保存</td><td>不能持久化保存，可能导致数据丢失</td></tr><tr><td>查询速度慢</td><td>存取速度快</td></tr></tbody></table><p>常见的NOSQL数据库<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200107160826641.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200107164533556.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>简单翻译下</p><blockquote><p>Redis是一个开源(BSD许可)的内存数据结构存储，用作数据库、缓存和消息代理。它支持诸如字符串、散列、列表、集、带范围查询的排序集、位图、hyperloglogs、带半径查询和流的地理空间索引等数据结构。Redis具有内置的复制、Lua脚本、LRU清除、事务和不同级别的磁盘持久性，并通过Redis Sentinel和带有Redis集群的自动分区提供高可用性</p></blockquote><p>redis的安装可以到官网下载，这里就不演示了。</p><h4 id="Redis是一种高级的key-value存储系统，其中value支持五种数据类型"><a href="#Redis是一种高级的key-value存储系统，其中value支持五种数据类型" class="headerlink" title="Redis是一种高级的key:value存储系统，其中value支持五种数据类型"></a>Redis是一种高级的<strong>key:value</strong>存储系统，其中value支持五种数据类型</h4><ul><li><p><strong>字符串（strings）</strong></p></li><li><p>字符串无序集合（Set）</p></li><li><p>有序字符串集合（zset）</p></li><li><p>字符串列表（List）</p></li><li><p>-哈希类型（hash）</p></li></ul><h3 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h3><p>字符串类型是 Redis 中最为基础的数据存储类型，<strong>它在 Redis 中以二进制保存，没有编码和解码的过程</strong>，String字符串类型的Value数据长度512M</p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>set key 值</td><td>添加字符串类型键和值</td></tr><tr><td>get  key 值</td><td>取出指定类型的值，没有返回null</td></tr><tr><td>del key</td><td>删除指定的key 返回删除的个数 没有返回0</td></tr><tr><td><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200107165300155.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></td><td></td></tr></tbody></table><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>我们可以将 Set 类型看作为没有排序的字符集合</p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>sadd  key  值1、值2</td><td>向集合中添加一个或多个元素</td></tr><tr><td>smembers key</td><td>查询指定集合所有的元素</td></tr><tr><td>sismember key 值</td><td>查询某个值是否存在 存在返回1、反则</td></tr><tr><td>srem key 值1、值2</td><td>删除指定元素</td></tr></tbody></table><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200107170803104.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><h3 id="Zset类型"><a href="#Zset类型" class="headerlink" title="Zset类型"></a>Zset类型</h3><p>集合一样也是string类型元素的集合,且不允许重复的成员。<br><strong>不同的是每个元素都会关联一个分数。redis正是通过分数来为集合中的成员进行从小到大的排序</strong>。有序集合的成员是唯一的,但分数(score)却可以重复，每个集合可存储40多亿个成员</p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>zadd key   分数  值</td><td>向集合 添加一个或多个元素</td></tr><tr><td>zrang key 开始 结束</td><td>返回集合中指定区间内的元素</td></tr><tr><td>zrem key 值</td><td>删除集合的 一个元素或多个元素</td></tr><tr><td>zcard key</td><td>获取集合中的元素数</td></tr><tr><td>zrank key 值</td><td>返回集合中指定成员的索引</td></tr></tbody></table><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200107174332626.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><h2 id="list类型"><a href="#list类型" class="headerlink" title="list类型"></a>list类型</h2><p> List 类型是按照插入顺序排序的字符串链表。和数据结构中的普通链表一样，我们可以在其左部(left)和右部(right)添加新的元素。</p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>lpush key 元素1 元素2</td><td>往链表左边添加元素 键不存在则 创建新链表</td></tr><tr><td>rpush key 元素1 元素2</td><td>往链表右边添加元素 键不存在则 创建新链表</td></tr><tr><td>lrange key 开始 结束</td><td>取出指定范围的元素列表 左边数第一个为0 右边数第一个为-1</td></tr><tr><td>lpop key</td><td>从左边删除一个元素</td></tr><tr><td>rpop key</td><td>从右边删除一个元素</td></tr><tr><td>llen key</td><td>得到指定链表的长度</td></tr><tr><td><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109160119551.jpg" alt="  "></td><td></td></tr><tr><td><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109160135742.jpg" alt="  "></td><td></td></tr></tbody></table><h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p>Redis 中的 Hash 类型可以看成具 String 的键和 String 的值 Map 容器，每一个 Hash 可以存储 40（42 亿 9千多个）亿个键值对。</p><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>hset key  MapKey 值</td><td>向指定的key中添加 hasnMap类型</td></tr><tr><td>hget key  MapKey</td><td>获取指定key中的指定HashMap</td></tr><tr><td>hmset key MapKey1 值  MapKey2 值</td><td>向一个键中设置多个Map和值</td></tr><tr><td>hmget key MapKey1 MapKey2</td><td>获取一个键中的多个Map</td></tr><tr><td>hdel key MapKey1 MapKey1</td><td>删除一个键中的多个Map</td></tr><tr><td>hgetall  key</td><td>得到一个键中的所有Map</td></tr><tr><td><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109163249198.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></td><td></td></tr><tr><td>批量插入Map</td><td></td></tr><tr><td><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109163307979.jpg" alt="  "></td><td></td></tr><tr><td>删除Map</td><td></td></tr><tr><td><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/2020010916333456.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></td><td></td></tr></tbody></table><h2 id="其他操作命令"><a href="#其他操作命令" class="headerlink" title="其他操作命令"></a>其他操作命令</h2><table><thead><tr><th>操作</th><th>作用</th></tr></thead><tbody><tr><td>keys  匹配字符</td><td>查询数据库的键 （ *   为匹配全部字符）</td></tr><tr><td>del key1  key2</td><td>删除任意键</td></tr><tr><td>exists key</td><td>判断指定键是否存在</td></tr><tr><td>type key</td><td>判断该key 属于哪种类型</td></tr><tr><td>select 数据库编号</td><td>选择指定的数据库</td></tr><tr><td>move key 数据库编号</td><td>将某个键移动到另一个数据库</td></tr><tr><td>Expire key  秒</td><td>设置过期时间</td></tr><tr><td>TTL key</td><td>返回剩余生存时间</td></tr><tr><td><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/2020010917015779.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="   "></td><td></td></tr></tbody></table><p>Redis数据库，Redis默认有16个数据库，我们可以通过Redis的一个图形化工具查看<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109170353435.jpg" alt=" "><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109171834997.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/2020010917220188.jpg" alt="  "><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109172228496.jpg" alt="  "></p><h4 id="设置过期时间（过期时为-2）"><a href="#设置过期时间（过期时为-2）" class="headerlink" title="设置过期时间（过期时为-2）"></a>设置过期时间（过期时为-2）</h4><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109174955819.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="   "></p><h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis的最大特色就是<strong>持久化机制</strong>，当发生服务器宕机等不可预料因素时，Redis会将符合条件的数据进行持久化，在重启时恢复数据。RDB 和 AOF 是 Redis 内部的两种数据持久化策略，这是两种不同的持久化策略，<strong>一种是基于内存快照，一种是基于操作日志</strong></p><h3 id="RDB持久化策略（基于内存快照）"><a href="#RDB持久化策略（基于内存快照）" class="headerlink" title="RDB持久化策略（基于内存快照）"></a>RDB持久化策略（基于内存快照）</h3><blockquote><p>RDB(Redis DataBase)持久化策略就是在符合一定条件下将内存所有数据持久化到磁盘中dump.rdb文件中。RDB策略是redis默认持久化策略。也叫快照策略。</p></blockquote><p>什么是快照策略，RDB持久化是指在某一段时间内将该内存下所有的数据存储为文件，当服务器丢失时，自动恢复到最新的一份RDB文件，简单点说就是相当于每隔一段时间就将Redis的文件<br>做一次备份，<strong>当然要满足一定的要求</strong> RDB持久化是Redis默认的持久化机制</p><p>在安装完Redis的目录下有个config文件<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109192335792.jpg" alt="  "><br>在该文件下我们可以找到这样一段话<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109192413876.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "><br>简单翻译一下就是</p><blockquote><p>将DB保存到磁盘上:<br>在下面的例子中行为将保存DB<br>900秒后(15分钟)如果至少1键改变了<br>300秒(5分钟)如果至少10键改变<br>60秒后如果至少10000键改变</p><p>也就是说：<br><strong>当数据在15分钟内改变了一个key，就会执行持久化机制<br>如果数据在5分钟内有10个key改变，就会执行持久化机制<br>如果数据在1分钟内有10000key改变，就会执行持久化机制</strong></p></blockquote><p>而我们持久化完的数据在哪里显示呢？<br>在该文件下面也有进行说明<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109193309603.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "><br>简单翻译下</p><blockquote><p>要将数据库转储到何处的文件名</p><p>于是我们就可以在Redis的安装目录下找到这个文件<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109193539993.jpg" alt="  "></p></blockquote><h3 id="关于RDB持久化机制"><a href="#关于RDB持久化机制" class="headerlink" title="关于RDB持久化机制"></a>关于RDB持久化机制</h3><p>RDB的持久化机制，我们可以在配置文件中修改持久化时间，但一般不建议修改，因为在Redis达到一定数据量时，频繁的进行RDB的持久化机制便是一个非常浪费性能的事。RDB的持久机制<br>不高，便意味可能RDB持久化会导致丢失一定的数据。以快的持久化时间来说，相当于我们还是有60秒的空档期。而这可以靠另一个持久化机制来解决。</p><h3 id="AOF持久化策略（基于操作日志）"><a href="#AOF持久化策略（基于操作日志）" class="headerlink" title="AOF持久化策略（基于操作日志）"></a>AOF持久化策略（基于操作日志）</h3><blockquote><p> AOF(append only file)策略，是基于操作日志实现的<br> 它的特点持久化的频率非常高了，默认每秒持久化1次。每一秒内将最新的<font color="red"><strong>写入与删除</strong></font>的命令进行持久化。</p></blockquote><p>AOF的持久化机制和RDB的持久化机制完全不同，AOF是基于日志文件操作的，简单点说就是RDB会将数据进行备份，而<font color="red"><strong>AOF备份的是操作</strong></font> , 就是说，AOF将你所有的<strong>写入和删除</strong>操作进行备份，当服务器宕机时，可以通过备份的操作还原数据。</p><p>在配置文件中有这么一小段<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109200757357.jpg"><br>简单翻译下</p><blockquote><p>可以同时启用AOF和RDB持久性，没有问题。如果在启动时启用了AOF，那么Redis将加载AOF，即具有更好持久性保证的文件</p></blockquote><h6 id="开启AOF机制"><a href="#开启AOF机制" class="headerlink" title="开启AOF机制"></a>开启AOF机制</h6><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109200859573.jpg" alt="  "></p><h5 id="AOF持久化选择"><a href="#AOF持久化选择" class="headerlink" title="AOF持久化选择"></a>AOF持久化选择</h5><p><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109201312398.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt=" "><br>简单翻译下</p><blockquote><p>默认设置是“每隔一秒”，因为这通常是正确的折衷<br>速度和数据安全。这取决于你是否能慢下来<br>“no”将允许操作系统在何时刷新输出缓冲区<br>为了更好的表现(但是如果你能接受一些数据丢失更多考虑的是快照的默认RDB持久性模式)，或者相反，使用“always”，虽然很慢，但是更安全。</p></blockquote><p>这里指的是AOF提供持久化的频率<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109201559103.jpg" alt="在这里插入图片描述"><br>always：指每次修改都进行持久化操作，效率是最低的，但也是最安全的。<br>everysec：指每秒持久化一次，默认使用<br>no：指的是不进行持久化，效率最高</p><h5 id="AOF的重写机制"><a href="#AOF的重写机制" class="headerlink" title="AOF的重写机制"></a>AOF的重写机制</h5><p>当AOF开启时每秒的操作都会进行持久化，这样会导致日志文件的过大<br>于是AOF就有了重写机制，同样在配置文件下<br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/20200109203646265.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="  "></p><p>简单翻译下</p><blockquote><p>这个基本大小与当前大小进行比较。如果当前大小大于指定的百分比，将触发重写。您需要为要重写的AOF文件指定一个最小的大小</p></blockquote><p><strong>默认当日志文件大小超过内存数据100%时触发重写<br>当日志文件达到64M时也触发重写</strong></p><h3 id="关于AOF持久化机制"><a href="#关于AOF持久化机制" class="headerlink" title="关于AOF持久化机制"></a>关于AOF持久化机制</h3><p> AOF策略的优点是显而易见的， 每秒持久化，具有更高的数据安全，如果服务器崩溃只会丢1秒内的数据，但缺点也是一样明显：由于持久化频率高，Redis的性能会变低。</p><p>值得注意的是AOF和RDB同时开启，默认使用AOF恢复数据，<br>因为AOF是秒级以内的容错。</p><h4 id="关于两者的选用"><a href="#关于两者的选用" class="headerlink" title="关于两者的选用"></a>关于两者的选用</h4><h5 id="官方建议"><a href="#官方建议" class="headerlink" title="官方建议"></a>官方建议</h5><blockquote><p>通常，如果你要想提供很高的数据保障性，那么建议你同时使用两种持久化方式。<br>如果你可以接受灾难带来的几分钟的数据丢失，那么你可以仅使用RDB。很多用户仅使用了AOF，但是我们建议，既然RDB可以时不时的给数据做个完整的快照，并且提供更快的重启，所以最好还是也使用RDB。<br>因此，我们希望可以在未来（长远计划）统一AOF和RDB成一种持久化模式。</p></blockquote><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>关于Redis就讲到这里了<br>有空再更！！！！<br>个人博客：<a href="https://juhaozero.github.io/">juhaozero的博客</a><br><img src="/medias/loading.gif" data-original="https://img-blog.csdnimg.cn/2020010920475983.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NoZXJsb2NraW4=,size_16,color_FFFFFF,t_70" alt="    "></p>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
